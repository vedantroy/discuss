diff --git a/node_modules/edgedb/dist/baseConn.js b/node_modules/edgedb/dist/baseConn.js
index 127ed67..9166969 100644
--- a/node_modules/edgedb/dist/baseConn.js
+++ b/node_modules/edgedb/dist/baseConn.js
@@ -1,841 +1,209 @@
 "use strict";
+const { Buffer } = require("./bufferPolyfill.js")
 /*!
+
  * This source file is part of the EdgeDB open source project.
+
  *
+
  * Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
+
  *
+
  * Licensed under the Apache License, Version 2.0 (the "License");
+
  * you may not use this file except in compliance with the License.
+
  * You may obtain a copy of the License at
+
  *
+
  *     http://www.apache.org/licenses/LICENSE-2.0
+
  *
+
  * Unless required by applicable law or agreed to in writing, software
+
  * distributed under the License is distributed on an "AS IS" BASIS,
+
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+
  * See the License for the specific language governing permissions and
+
  * limitations under the License.
+
  */
+
 var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+
     if (k2 === undefined) k2 = k;
+
     Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
+
 }) : (function(o, m, k, k2) {
+
     if (k2 === undefined) k2 = k;
+
     o[k2] = m[k];
+
 }));
+
 var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+
     Object.defineProperty(o, "default", { enumerable: true, value: v });
+
 }) : function(o, v) {
+
     o["default"] = v;
+
 });
+
 var __importStar = (this && this.__importStar) || function (mod) {
+
     if (mod && mod.__esModule) return mod;
+
     var result = {};
+
     if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+
     __setModuleDefault(result, mod);
+
     return result;
+
 };
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
+
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.BaseRawConnection = exports.PROTO_VER_MIN = exports.PROTO_VER = void 0;
-const codecs_1 = require("./codecs/codecs");
-const namedtuple_1 = require("./codecs/namedtuple");
-const object_1 = require("./codecs/object");
-const tuple_1 = require("./codecs/tuple");
-const utils_1 = require("./utils");
-const errors = __importStar(require("./errors"));
-const resolve_1 = require("./errors/resolve");
-const ifaces_1 = require("./ifaces");
-const buffer_1 = require("./primitives/buffer");
-const chars = __importStar(require("./primitives/chars"));
-const event_1 = __importDefault(require("./primitives/event"));
-const lru_1 = __importDefault(require("./primitives/lru"));
-exports.PROTO_VER = [0, 14];
-exports.PROTO_VER_MIN = [0, 9];
-var TransactionStatus;
-(function (TransactionStatus) {
-    TransactionStatus[TransactionStatus["TRANS_IDLE"] = 0] = "TRANS_IDLE";
-    TransactionStatus[TransactionStatus["TRANS_ACTIVE"] = 1] = "TRANS_ACTIVE";
-    TransactionStatus[TransactionStatus["TRANS_INTRANS"] = 2] = "TRANS_INTRANS";
-    TransactionStatus[TransactionStatus["TRANS_INERROR"] = 3] = "TRANS_INERROR";
-    TransactionStatus[TransactionStatus["TRANS_UNKNOWN"] = 4] = "TRANS_UNKNOWN";
-})(TransactionStatus || (TransactionStatus = {}));
-var Capabilities;
-(function (Capabilities) {
-    Capabilities[Capabilities["MODIFICATONS"] = 1] = "MODIFICATONS";
-    Capabilities[Capabilities["SESSION_CONFIG"] = 2] = "SESSION_CONFIG";
-    Capabilities[Capabilities["TRANSACTION"] = 4] = "TRANSACTION";
-    Capabilities[Capabilities["DDL"] = 8] = "DDL";
-    Capabilities[Capabilities["PERSISTENT_CONFIG"] = 16] = "PERSISTENT_CONFIG";
-})(Capabilities || (Capabilities = {}));
-const NO_TRANSACTION_CAPABILITIES_BYTES = Buffer.from([
-    255,
-    255,
-    255,
-    255,
-    255,
-    255,
-    255,
-    255 & ~Capabilities.TRANSACTION & ~Capabilities.SESSION_CONFIG,
-]);
-const OLD_ERROR_CODES = new Map([
-    [84082689, 84082945],
-    [84082690, 84082946],
-]);
-class BaseRawConnection {
-    constructor(registry) {
-        Object.defineProperty(this, "connected", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: false
-        });
-        Object.defineProperty(this, "alwaysUseOptimisticFlow", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: false
-        });
-        Object.defineProperty(this, "exposeErrorAttributes", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: false
-        });
-        Object.defineProperty(this, "lastStatus", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: void 0
-        });
-        Object.defineProperty(this, "codecsRegistry", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: void 0
-        });
-        Object.defineProperty(this, "queryCodecCache", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: void 0
-        });
-        Object.defineProperty(this, "serverSecret", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: void 0
-        });
-        Object.defineProperty(this, "serverSettings", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: void 0
-        });
-        Object.defineProperty(this, "serverXactStatus", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: void 0
-        });
-        Object.defineProperty(this, "buffer", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: void 0
-        });
-        Object.defineProperty(this, "messageWaiter", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: void 0
-        });
-        Object.defineProperty(this, "connWaiter", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: void 0
-        });
-        Object.defineProperty(this, "connAbortWaiter", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: void 0
-        });
-        Object.defineProperty(this, "_abortedWith", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: null
-        });
-        Object.defineProperty(this, "protocolVersion", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: exports.PROTO_VER
-        });
-        this.buffer = new buffer_1.ReadMessageBuffer();
-        this.codecsRegistry = registry;
-        this.queryCodecCache = new lru_1.default({ capacity: 1000 });
-        this.lastStatus = null;
-        this.serverSecret = null;
-        this.serverSettings = {};
-        this.serverXactStatus = TransactionStatus.TRANS_UNKNOWN;
-        this.messageWaiter = null;
-        this.connWaiter = new event_1.default();
-        this.connAbortWaiter = new event_1.default();
-    }
-    throwNotImplemented(method) {
-        throw new Error(`method ${method} is not implemented`);
-    }
-    async _waitForMessage() {
-        this.throwNotImplemented('_waitForMessage');
-    }
-    _sendData(data) {
-        this.throwNotImplemented('_sendData');
-    }
-    getConnAbortError() {
-        var _a;
-        return ((_a = this._abortedWith) !== null && _a !== void 0 ? _a : new errors.InterfaceError(`client has been closed`));
-    }
-    _checkState() {
-        if (this.isClosed()) {
-            throw this.getConnAbortError();
-        }
-    }
-    _abortWithError(err) {
-        this._abortedWith = err;
-        this._abort();
-    }
-    _ignoreHeaders() {
-        let numFields = this.buffer.readInt16();
-        while (numFields) {
-            this.buffer.readInt16();
-            this.buffer.readLenPrefixedBuffer();
-            numFields--;
-        }
-    }
-    _abortWaiters(err) {
-        var _a;
-        if (!this.connWaiter.done) {
-            this.connWaiter.setError(err);
-        }
-        (_a = this.messageWaiter) === null || _a === void 0 ? void 0 : _a.setError(err);
-        this.messageWaiter = null;
-    }
-    _parseHeaders() {
-        const ret = new Map();
-        let numFields = this.buffer.readInt16();
-        while (numFields) {
-            const key = this.buffer.readInt16();
-            const value = this.buffer.readLenPrefixedBuffer();
-            ret.set(key, value);
-            numFields--;
-        }
-        return ret;
-    }
-    _parseDescribeTypeMessage() {
-        const headers = this._parseHeaders();
-        let capabilities = -1;
-        if (headers.has(ifaces_1.HeaderCodes.capabilities)) {
-            capabilities = Number(headers.get(ifaces_1.HeaderCodes.capabilities).readBigInt64BE());
-        }
-        const cardinality = this.buffer.readChar();
-        const inTypeId = this.buffer.readUUID();
-        const inTypeData = this.buffer.readLenPrefixedBuffer();
-        const outTypeId = this.buffer.readUUID();
-        const outTypeData = this.buffer.readLenPrefixedBuffer();
-        this.buffer.finishMessage();
-        let inCodec = this.codecsRegistry.getCodec(inTypeId);
-        if (inCodec == null) {
-            inCodec = this.codecsRegistry.buildCodec(inTypeData, this.protocolVersion);
-        }
-        let outCodec = this.codecsRegistry.getCodec(outTypeId);
-        if (outCodec == null) {
-            outCodec = this.codecsRegistry.buildCodec(outTypeData, this.protocolVersion);
-        }
-        return [
-            cardinality,
-            inCodec,
-            outCodec,
-            capabilities,
-            inTypeData,
-            outTypeData,
-        ];
-    }
-    _parseCommandCompleteMessage() {
-        this._ignoreHeaders();
-        const status = this.buffer.readString();
-        this.buffer.finishMessage();
-        return status;
-    }
-    _parseErrorMessage() {
-        var _a;
-        this.buffer.readChar();
-        const code = this.buffer.readUInt32();
-        const message = this.buffer.readString();
-        const errorType = (0, resolve_1.resolveErrorCode)((_a = OLD_ERROR_CODES.get(code)) !== null && _a !== void 0 ? _a : code);
-        const err = new errorType(message);
-        if (this.exposeErrorAttributes) {
-            err.attrs = this._parseHeaders();
-        }
-        else {
-            this._ignoreHeaders();
-        }
-        this.buffer.finishMessage();
-        return err;
-    }
-    _parseSyncMessage() {
-        this._parseHeaders();
-        const status = this.buffer.readChar();
-        switch (status) {
-            case chars.$I:
-                this.serverXactStatus = TransactionStatus.TRANS_IDLE;
-                break;
-            case chars.$T:
-                this.serverXactStatus = TransactionStatus.TRANS_INTRANS;
-                break;
-            case chars.$E:
-                this.serverXactStatus = TransactionStatus.TRANS_INERROR;
-                break;
-            default:
-                this.serverXactStatus = TransactionStatus.TRANS_UNKNOWN;
-        }
-        this.buffer.finishMessage();
-    }
-    _parseDataMessages(codec, result) {
-        const frb = buffer_1.ReadBuffer.alloc();
-        const $D = chars.$D;
-        const buffer = this.buffer;
-        if (Array.isArray(result)) {
-            while (buffer.takeMessageType($D)) {
-                buffer.consumeMessageInto(frb);
-                frb.discard(6);
-                result.push(codec.decode(frb));
-                frb.finish();
-            }
-        }
-        else {
-            while (buffer.takeMessageType($D)) {
-                const msg = buffer.consumeMessage();
-                result.writeChar($D);
-                result.writeInt32(msg.length + 4);
-                result.writeBuffer(msg);
-            }
-        }
-    }
-    _parseServerSettings(name, value) {
-        switch (name) {
-            case "suggested_pool_concurrency":
-                this.serverSettings.suggested_pool_concurrency = parseInt(value.toString("utf8"), 10);
-                break;
-            case "system_config":
-                const buf = new buffer_1.ReadBuffer(value);
-                const typedescLen = buf.readInt32() - 16;
-                const typedescId = buf.readUUID();
-                const typedesc = buf.readBuffer(typedescLen);
-                let codec = this.codecsRegistry.getCodec(typedescId);
-                if (codec === null) {
-                    codec = this.codecsRegistry.buildCodec(typedesc, this.protocolVersion);
-                }
-                buf.discard(4);
-                const data = codec.decode(buf);
-                buf.finish();
-                this.serverSettings.system_config = data;
-                break;
-            default:
-                this.serverSettings[name] = value;
-                break;
-        }
-    }
-    _fallthrough() {
-        const mtype = this.buffer.getMessageType();
-        switch (mtype) {
-            case chars.$S: {
-                const name = this.buffer.readString();
-                const value = this.buffer.readLenPrefixedBuffer();
-                this._parseServerSettings(name, value);
-                this.buffer.finishMessage();
-                break;
-            }
-            case chars.$L: {
-                const severity = this.buffer.readChar();
-                const code = this.buffer.readUInt32();
-                const message = this.buffer.readString();
-                this._parseHeaders();
-                this.buffer.finishMessage();
-                console.info("SERVER MESSAGE", severity, code, message);
-                break;
-            }
-            default:
-                throw new Error(`unexpected message type ${mtype} ("${chars.chr(mtype)}")`);
-        }
-    }
-    async _parse(query, asJson, expectOne, alwaysDescribe, options) {
-        var _a;
-        const wb = new buffer_1.WriteMessageBuffer();
-        const parseSendsTypeData = (0, utils_1.versionGreaterThanOrEqual)(this.protocolVersion, [0, 14]);
-        wb.beginMessage(chars.$P)
-            .writeHeaders({
-            explicitObjectids: "true",
-            ...((_a = options === null || options === void 0 ? void 0 : options.headers) !== null && _a !== void 0 ? _a : {}),
-            allowCapabilities: NO_TRANSACTION_CAPABILITIES_BYTES,
-        })
-            .writeChar(asJson ? chars.$j : chars.$b)
-            .writeChar(expectOne ? chars.$o : chars.$m)
-            .writeString("")
-            .writeString(query)
-            .endMessage();
-        wb.writeSync();
-        this._sendData(wb.unwrap());
-        let cardinality;
-        let inTypeId;
-        let outTypeId;
-        let inCodec;
-        let outCodec;
-        let capabilities = -1;
-        let parsing = true;
-        let error = null;
-        let inCodecData = null;
-        let outCodecData = null;
-        while (parsing) {
-            if (!this.buffer.takeMessage()) {
-                await this._waitForMessage();
-            }
-            const mtype = this.buffer.getMessageType();
-            switch (mtype) {
-                case chars.$1: {
-                    const headers = this._parseHeaders();
-                    if (headers.has(ifaces_1.HeaderCodes.capabilities)) {
-                        capabilities = Number(headers.get(ifaces_1.HeaderCodes.capabilities).readBigInt64BE());
-                    }
-                    cardinality = this.buffer.readChar();
-                    if (parseSendsTypeData) {
-                        inTypeId = this.buffer.readUUID();
-                        inCodecData = this.buffer.readLenPrefixedBuffer();
-                        outTypeId = this.buffer.readUUID();
-                        outCodecData = this.buffer.readLenPrefixedBuffer();
-                    }
-                    else {
-                        inTypeId = this.buffer.readUUID();
-                        outTypeId = this.buffer.readUUID();
-                    }
-                    this.buffer.finishMessage();
-                    break;
-                }
-                case chars.$E: {
-                    error = this._parseErrorMessage();
-                    break;
-                }
-                case chars.$Z: {
-                    this._parseSyncMessage();
-                    parsing = false;
-                    break;
-                }
-                default:
-                    this._fallthrough();
-            }
-        }
-        if (error != null) {
-            throw error;
-        }
-        if (inTypeId == null || outTypeId == null) {
-            throw new Error("did not receive in/out type ids in Parse response");
-        }
-        inCodec = this.codecsRegistry.getCodec(inTypeId);
-        outCodec = this.codecsRegistry.getCodec(outTypeId);
-        if (inCodec == null && inCodecData != null) {
-            inCodec = this.codecsRegistry.buildCodec(inCodecData, this.protocolVersion);
-        }
-        if (outCodec == null && outCodecData != null) {
-            outCodec = this.codecsRegistry.buildCodec(outCodecData, this.protocolVersion);
-        }
-        if (inCodec == null ||
-            outCodec == null ||
-            (alwaysDescribe && !parseSendsTypeData)) {
-            if (parseSendsTypeData) {
-                throw new Error("in/out codecs were not sent");
-            }
-            wb.reset();
-            wb.beginMessage(chars.$D)
-                .writeInt16(0)
-                .writeChar(chars.$T)
-                .writeString("")
-                .endMessage()
-                .writeSync();
-            this._sendData(wb.unwrap());
-            parsing = true;
-            while (parsing) {
-                if (!this.buffer.takeMessage()) {
-                    await this._waitForMessage();
-                }
-                const mtype = this.buffer.getMessageType();
-                switch (mtype) {
-                    case chars.$T: {
-                        try {
-                            [
-                                cardinality,
-                                inCodec,
-                                outCodec,
-                                capabilities,
-                                inCodecData,
-                                outCodecData,
-                            ] = this._parseDescribeTypeMessage();
-                        }
-                        catch (e) {
-                            error = e;
-                        }
-                        break;
-                    }
-                    case chars.$E: {
-                        error = this._parseErrorMessage();
-                        break;
-                    }
-                    case chars.$Z: {
-                        this._parseSyncMessage();
-                        parsing = false;
-                        break;
-                    }
-                    default:
-                        this._fallthrough();
-                }
-            }
-            if (error != null) {
-                throw error;
-            }
-        }
-        if (cardinality == null || outCodec == null || inCodec == null) {
-            throw new Error("failed to receive type information in response to a Parse message");
-        }
-        return [
-            cardinality,
-            inCodec,
-            outCodec,
-            capabilities,
-            inCodecData,
-            outCodecData,
-        ];
-    }
-    _encodeArgs(args, inCodec) {
-        if ((0, utils_1.versionGreaterThanOrEqual)(this.protocolVersion, [0, 12])) {
-            if (inCodec === codecs_1.NULL_CODEC) {
-                if (args != null) {
-                    throw new errors.QueryArgumentError(`This query does not contain any query parameters, ` +
-                        `but query arguments were provided to the 'query*()' method`);
-                }
-                return codecs_1.NullCodec.BUFFER;
-            }
-            if (inCodec instanceof object_1.ObjectCodec) {
-                return inCodec.encodeArgs(args);
-            }
-            throw new Error("invalid input codec");
-        }
-        else {
-            if (inCodec === tuple_1.EMPTY_TUPLE_CODEC) {
-                if (args != null) {
-                    throw new errors.QueryArgumentError(`This query does not contain any query parameters, ` +
-                        `but query arguments were provided to the 'query*()' method`);
-                }
-                return tuple_1.EmptyTupleCodec.BUFFER;
-            }
-            if (inCodec instanceof namedtuple_1.NamedTupleCodec ||
-                inCodec instanceof tuple_1.TupleCodec) {
-                return inCodec.encodeArgs(args);
-            }
-            throw new Error("invalid input codec");
-        }
-    }
-    async _executeFlow(args, inCodec, outCodec, result) {
-        const wb = new buffer_1.WriteMessageBuffer();
-        wb.beginMessage(chars.$E)
-            .writeHeaders({ allowCapabilities: NO_TRANSACTION_CAPABILITIES_BYTES })
-            .writeString("")
-            .writeBuffer(this._encodeArgs(args, inCodec))
-            .endMessage()
-            .writeSync();
-        this._sendData(wb.unwrap());
-        let parsing = true;
-        let error = null;
-        while (parsing) {
-            if (!this.buffer.takeMessage()) {
-                await this._waitForMessage();
-            }
-            const mtype = this.buffer.getMessageType();
-            switch (mtype) {
-                case chars.$D: {
-                    if (error == null) {
-                        try {
-                            this._parseDataMessages(outCodec, result);
-                        }
-                        catch (e) {
-                            error = e;
-                            this.buffer.finishMessage();
-                        }
-                    }
-                    else {
-                        this.buffer.discardMessage();
-                    }
-                    break;
-                }
-                case chars.$C: {
-                    this.lastStatus = this._parseCommandCompleteMessage();
-                    break;
-                }
-                case chars.$E: {
-                    error = this._parseErrorMessage();
-                    break;
-                }
-                case chars.$Z: {
-                    this._parseSyncMessage();
-                    parsing = false;
-                    break;
-                }
-                default:
-                    this._fallthrough();
-            }
-        }
-        if (error != null) {
-            throw error;
-        }
-    }
-    async _optimisticExecuteFlow(args, asJson, expectOne, requiredOne, inCodec, outCodec, query, result, options) {
-        var _a;
-        const wb = new buffer_1.WriteMessageBuffer();
-        wb.beginMessage(chars.$O);
-        wb.writeHeaders({
-            explicitObjectids: "true",
-            ...((_a = options === null || options === void 0 ? void 0 : options.headers) !== null && _a !== void 0 ? _a : {}),
-            allowCapabilities: NO_TRANSACTION_CAPABILITIES_BYTES,
-        });
-        wb.writeChar(asJson ? chars.$j : chars.$b);
-        wb.writeChar(expectOne ? chars.$o : chars.$m);
-        wb.writeString(query);
-        wb.writeBuffer(inCodec.tidBuffer);
-        wb.writeBuffer(outCodec.tidBuffer);
-        wb.writeBuffer(this._encodeArgs(args, inCodec));
-        wb.endMessage();
-        wb.writeSync();
-        this._sendData(wb.unwrap());
-        let reExec = false;
-        let error = null;
-        let parsing = true;
-        let newCard = null;
-        let capabilities = -1;
-        while (parsing) {
-            if (!this.buffer.takeMessage()) {
-                await this._waitForMessage();
-            }
-            const mtype = this.buffer.getMessageType();
-            switch (mtype) {
-                case chars.$D: {
-                    if (error == null) {
-                        try {
-                            this._parseDataMessages(outCodec, result);
-                        }
-                        catch (e) {
-                            error = e;
-                            this.buffer.finishMessage();
-                        }
-                    }
-                    else {
-                        this.buffer.discardMessage();
-                    }
-                    break;
-                }
-                case chars.$C: {
-                    this.lastStatus = this._parseCommandCompleteMessage();
-                    break;
-                }
-                case chars.$Z: {
-                    this._parseSyncMessage();
-                    parsing = false;
-                    break;
-                }
-                case chars.$T: {
-                    try {
-                        [newCard, inCodec, outCodec, capabilities] =
-                            this._parseDescribeTypeMessage();
-                        const key = this._getQueryCacheKey(query, asJson, expectOne);
-                        this.queryCodecCache.set(key, [
-                            newCard,
-                            inCodec,
-                            outCodec,
-                            capabilities,
-                        ]);
-                        reExec = true;
-                    }
-                    catch (e) {
-                        error = e;
-                    }
-                    break;
-                }
-                case chars.$E: {
-                    error = this._parseErrorMessage();
-                    break;
-                }
-                default:
-                    this._fallthrough();
-            }
-        }
-        if (error != null) {
-            throw error;
-        }
-        if (reExec) {
-            this._validateFetchCardinality(newCard, asJson, requiredOne);
-            return await this._executeFlow(args, inCodec, outCodec, result);
-        }
-    }
-    _getQueryCacheKey(query, asJson, expectOne) {
-        return [asJson, expectOne, query.length, query].join(";");
-    }
-    _validateFetchCardinality(card, asJson, requiredOne) {
-        if (requiredOne && card === chars.$n) {
-            throw new errors.NoDataError(`query executed via queryRequiredSingle${asJson ? "JSON" : ""}() returned no data`);
-        }
-    }
-    async fetch(query, args = null, asJson, expectOne, requiredOne = false) {
-        var _a;
-        this._checkState();
-        const key = this._getQueryCacheKey(query, asJson, expectOne);
-        const ret = new Array();
-        if (this.queryCodecCache.has(key)) {
-            const [card, inCodec, outCodec] = this.queryCodecCache.get(key);
-            this._validateFetchCardinality(card, asJson, requiredOne);
-            await this._optimisticExecuteFlow(args, asJson, expectOne, requiredOne, inCodec, outCodec, query, ret);
-        }
-        else {
-            const [card, inCodec, outCodec, capabilities] = await this._parse(query, asJson, expectOne, false);
-            this._validateFetchCardinality(card, asJson, requiredOne);
-            this.queryCodecCache.set(key, [card, inCodec, outCodec, capabilities]);
-            if (this.alwaysUseOptimisticFlow) {
-                await this._optimisticExecuteFlow(args, asJson, expectOne, requiredOne, inCodec, outCodec, query, ret);
-            }
-            else {
-                await this._executeFlow(args, inCodec, outCodec, ret);
-            }
-        }
-        if (expectOne) {
-            if (requiredOne && !ret.length) {
-                throw new errors.NoDataError("query returned no data");
-            }
-            else {
-                return (_a = ret[0]) !== null && _a !== void 0 ? _a : (asJson ? "null" : null);
-            }
-        }
-        else {
-            if (ret && ret.length) {
-                if (asJson) {
-                    return ret[0];
-                }
-                else {
-                    return ret;
-                }
-            }
-            else {
-                if (asJson) {
-                    return "[]";
-                }
-                else {
-                    return ret;
-                }
-            }
-        }
-    }
-    getQueryCapabilities(query, asJson, expectOne) {
-        var _a, _b;
-        const key = this._getQueryCacheKey(query, asJson, expectOne);
-        return (_b = (_a = this.queryCodecCache.get(key)) === null || _a === void 0 ? void 0 : _a[3]) !== null && _b !== void 0 ? _b : null;
-    }
-    async execute(query, allowTransactionCommands = false) {
-        this._checkState();
-        const wb = new buffer_1.WriteMessageBuffer();
-        wb.beginMessage(chars.$Q)
-            .writeHeaders({
-            allowCapabilities: !allowTransactionCommands
-                ? NO_TRANSACTION_CAPABILITIES_BYTES
-                : undefined,
-        })
-            .writeString(query)
-            .endMessage();
-        this._sendData(wb.unwrap());
-        let error = null;
-        let parsing = true;
-        while (parsing) {
-            if (!this.buffer.takeMessage()) {
-                await this._waitForMessage();
-            }
-            const mtype = this.buffer.getMessageType();
-            switch (mtype) {
-                case chars.$C: {
-                    this.lastStatus = this._parseCommandCompleteMessage();
-                    break;
-                }
-                case chars.$Z: {
-                    this._parseSyncMessage();
-                    parsing = false;
-                    break;
-                }
-                case chars.$E: {
-                    error = this._parseErrorMessage();
-                    break;
-                }
-                default:
-                    this._fallthrough();
-            }
-        }
-        if (error != null) {
-            throw error;
-        }
-    }
-    async resetState() {
-        if (this.connected &&
-            this.serverXactStatus !== TransactionStatus.TRANS_IDLE) {
-            try {
-                await this.execute(`rollback`, true);
-            }
-            catch {
-                this._abortWithError(new errors.ClientConnectionClosedError("failed to reset state"));
-            }
-        }
-    }
-    _abort() {
-        this.connected = false;
-        this._abortWaiters(this.getConnAbortError());
-        if (!this.connAbortWaiter.done) {
-            this.connAbortWaiter.set();
-        }
-    }
-    isClosed() {
-        return !this.connected;
-    }
-    async close() {
-        this._abort();
-    }
-    async rawParse(query, headers) {
-        const result = await this._parse(query, false, false, true, {
-            headers,
-        });
-        return [
-            result[1],
-            result[2],
-            result[4],
-            result[5],
-            this.protocolVersion,
-        ];
-    }
-    async rawExecute(query, outCodec, headers, inCodec, args = null) {
-        const result = new buffer_1.WriteBuffer();
-        inCodec =
-            inCodec !== null && inCodec !== void 0 ? inCodec : ((0, utils_1.versionGreaterThanOrEqual)(this.protocolVersion, [0, 12])
-                ? codecs_1.NULL_CODEC
-                : tuple_1.EMPTY_TUPLE_CODEC);
-        await this._optimisticExecuteFlow(args, false, false, false, inCodec, outCodec, query, result, { headers });
-        return result.unwrap();
-    }
-    async rawExecuteScript(script) {
-        await this.execute(script, true);
-    }
+
+exports.decodeMicrosecondsToEdgeDBDateTime = exports.decodeInt64ToString = exports.inspect = void 0;
+
+const bi = __importStar(require("./primitives/bigint"));
+
+const dateutil_1 = require("./datatypes/dateutil");
+
+let inspect = (() => {
+
+    const f = () => null;
+
+    f.custom = Symbol();
+
+    return f;
+
+})();
+
+exports.inspect = inspect;
+
+if (typeof window === "undefined" && typeof Deno === "undefined") {
+
+    const utilMod = require("util");
+
+    exports.inspect = inspect = utilMod.inspect;
+
+}
+
+function decodeInt64ToString(buf) {
+
+    if (buf.length !== 8) {
+
+        throw new Error("expected 8 bytes buffer");
+
+    }
+
+    let inp = Array.from(buf);
+
+    let negative = false;
+
+    if (inp[0] & 0x80) {
+
+        inp = inp.map((x) => x ^ 0xff);
+
+        inp[inp.length - 1]++;
+
+        negative = true;
+
+    }
+
+    let result = "0";
+
+    for (const digit of inp) {
+
+        let acc = digit;
+
+        let ret = "";
+
+        for (let j = result.length - 1; j >= 0; j--) {
+
+            const num = parseInt(result[j], 10) * 256 + acc;
+
+            ret = (num % 10) + ret;
+
+            acc = Math.floor(num / 10);
+
+        }
+
+        result = acc ? acc + ret : ret;
+
+    }
+
+    return negative ? `-${result}` : result;
+
+}
+
+exports.decodeInt64ToString = decodeInt64ToString;
+
+const DATESHIFT_ORD = (0, dateutil_1.ymd2ord)(2000, 1, 1);
+
+function decodeMicrosecondsToEdgeDBDateTime(microseconds) {
+
+    const bigUsPerDay = bi.make(86400000000);
+
+    const dayNumber = bi.div(microseconds, bigUsPerDay);
+
+    let timeUs = Number(bi.sub(microseconds, bi.mul(dayNumber, bigUsPerDay)));
+
+    let ord = Number(dayNumber) + DATESHIFT_ORD;
+
+    if (timeUs < 0) {
+
+        timeUs = 86400000000 + timeUs;
+
+        ord -= 1;
+
+    }
+
+    const [_year, month, day] = (0, dateutil_1.ord2ymd)(ord);
+
+    const year = _year <= 0 ? _year - 1 : _year;
+
+    const hour = Math.floor(timeUs / 3600000000);
+
+    timeUs -= hour * 3600000000;
+
+    const minute = Math.floor(timeUs / 60000000);
+
+    timeUs -= minute * 60000000;
+
+    const second = Math.floor(timeUs / 1000000);
+
+    timeUs -= second * 1000000;
+
+    return {
+
+        year,
+
+        month,
+
+        day,
+
+        hour,
+
+        minute,
+
+        second,
+
+        microsecond: timeUs,
+
+    };
+
 }
-exports.BaseRawConnection = BaseRawConnection;
+
+exports.decodeMicrosecondsToEdgeDBDateTime = decodeMicrosecondsToEdgeDBDateTime;
diff --git a/node_modules/edgedb/dist/bufferPolyfill.js b/node_modules/edgedb/dist/bufferPolyfill.js
new file mode 100644
index 0000000..22c6e53
--- /dev/null
+++ b/node_modules/edgedb/dist/bufferPolyfill.js
@@ -0,0 +1,4215 @@
+/*!
+
+ * The buffer module from node.js, for the browser.
+
+ *
+
+ * @author   Feross Aboukhadijeh <https://feross.org>
+
+ * @license  MIT
+
+ */
+
+/* eslint-disable no-proto */
+
+
+
+'use strict'
+
+
+
+const base64 = require('base64-js')
+
+const ieee754 = require('ieee754')
+
+const customInspectSymbol =
+
+  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
+
+    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
+
+    : null
+
+
+
+exports.Buffer = Buffer
+
+exports.SlowBuffer = SlowBuffer
+
+exports.INSPECT_MAX_BYTES = 50
+
+
+
+const K_MAX_LENGTH = 0x7fffffff
+
+exports.kMaxLength = K_MAX_LENGTH
+
+
+
+/**
+
+ * If `Buffer.TYPED_ARRAY_SUPPORT`:
+
+ *   === true    Use Uint8Array implementation (fastest)
+
+ *   === false   Print warning and recommend using `buffer` v4.x which has an Object
+
+ *               implementation (most compatible, even IE6)
+
+ *
+
+ * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
+
+ * Opera 11.6+, iOS 4.2+.
+
+ *
+
+ * We report that the browser does not support typed arrays if the are not subclassable
+
+ * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
+
+ * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
+
+ * for __proto__ and has a buggy typed array implementation.
+
+ */
+
+Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()
+
+
+
+if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
+
+    typeof console.error === 'function') {
+
+  console.error(
+
+    'This browser lacks typed array (Uint8Array) support which is required by ' +
+
+    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
+
+  )
+
+}
+
+
+
+function typedArraySupport () {
+
+  // Can typed array instances can be augmented?
+
+  try {
+
+    const arr = new Uint8Array(1)
+
+    const proto = { foo: function () { return 42 } }
+
+    Object.setPrototypeOf(proto, Uint8Array.prototype)
+
+    Object.setPrototypeOf(arr, proto)
+
+    return arr.foo() === 42
+
+  } catch (e) {
+
+    return false
+
+  }
+
+}
+
+
+
+Object.defineProperty(Buffer.prototype, 'parent', {
+
+  enumerable: true,
+
+  get: function () {
+
+    if (!Buffer.isBuffer(this)) return undefined
+
+    return this.buffer
+
+  }
+
+})
+
+
+
+Object.defineProperty(Buffer.prototype, 'offset', {
+
+  enumerable: true,
+
+  get: function () {
+
+    if (!Buffer.isBuffer(this)) return undefined
+
+    return this.byteOffset
+
+  }
+
+})
+
+
+
+function createBuffer (length) {
+
+  if (length > K_MAX_LENGTH) {
+
+    throw new RangeError('The value "' + length + '" is invalid for option "size"')
+
+  }
+
+  // Return an augmented `Uint8Array` instance
+
+  const buf = new Uint8Array(length)
+
+  Object.setPrototypeOf(buf, Buffer.prototype)
+
+  return buf
+
+}
+
+
+
+/**
+
+ * The Buffer constructor returns instances of `Uint8Array` that have their
+
+ * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
+
+ * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
+
+ * and the `Uint8Array` methods. Square bracket notation works as expected -- it
+
+ * returns a single octet.
+
+ *
+
+ * The `Uint8Array` prototype remains unmodified.
+
+ */
+
+
+
+function Buffer (arg, encodingOrOffset, length) {
+
+  // Common case.
+
+  if (typeof arg === 'number') {
+
+    if (typeof encodingOrOffset === 'string') {
+
+      throw new TypeError(
+
+        'The "string" argument must be of type string. Received type number'
+
+      )
+
+    }
+
+    return allocUnsafe(arg)
+
+  }
+
+  return from(arg, encodingOrOffset, length)
+
+}
+
+
+
+Buffer.poolSize = 8192 // not used by this implementation
+
+
+
+function from (value, encodingOrOffset, length) {
+
+  if (typeof value === 'string') {
+
+    return fromString(value, encodingOrOffset)
+
+  }
+
+
+
+  if (ArrayBuffer.isView(value)) {
+
+    return fromArrayView(value)
+
+  }
+
+
+
+  if (value == null) {
+
+    throw new TypeError(
+
+      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
+
+      'or Array-like Object. Received type ' + (typeof value)
+
+    )
+
+  }
+
+
+
+  if (isInstance(value, ArrayBuffer) ||
+
+      (value && isInstance(value.buffer, ArrayBuffer))) {
+
+    return fromArrayBuffer(value, encodingOrOffset, length)
+
+  }
+
+
+
+  if (typeof SharedArrayBuffer !== 'undefined' &&
+
+      (isInstance(value, SharedArrayBuffer) ||
+
+      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
+
+    return fromArrayBuffer(value, encodingOrOffset, length)
+
+  }
+
+
+
+  if (typeof value === 'number') {
+
+    throw new TypeError(
+
+      'The "value" argument must not be of type number. Received type number'
+
+    )
+
+  }
+
+
+
+  const valueOf = value.valueOf && value.valueOf()
+
+  if (valueOf != null && valueOf !== value) {
+
+    return Buffer.from(valueOf, encodingOrOffset, length)
+
+  }
+
+
+
+  const b = fromObject(value)
+
+  if (b) return b
+
+
+
+  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
+
+      typeof value[Symbol.toPrimitive] === 'function') {
+
+    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
+
+  }
+
+
+
+  throw new TypeError(
+
+    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
+
+    'or Array-like Object. Received type ' + (typeof value)
+
+  )
+
+}
+
+
+
+/**
+
+ * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
+
+ * if value is a number.
+
+ * Buffer.from(str[, encoding])
+
+ * Buffer.from(array)
+
+ * Buffer.from(buffer)
+
+ * Buffer.from(arrayBuffer[, byteOffset[, length]])
+
+ **/
+
+Buffer.from = function (value, encodingOrOffset, length) {
+
+  return from(value, encodingOrOffset, length)
+
+}
+
+
+
+// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
+
+// https://github.com/feross/buffer/pull/148
+
+Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
+
+Object.setPrototypeOf(Buffer, Uint8Array)
+
+
+
+function assertSize (size) {
+
+  if (typeof size !== 'number') {
+
+    throw new TypeError('"size" argument must be of type number')
+
+  } else if (size < 0) {
+
+    throw new RangeError('The value "' + size + '" is invalid for option "size"')
+
+  }
+
+}
+
+
+
+function alloc (size, fill, encoding) {
+
+  assertSize(size)
+
+  if (size <= 0) {
+
+    return createBuffer(size)
+
+  }
+
+  if (fill !== undefined) {
+
+    // Only pay attention to encoding if it's a string. This
+
+    // prevents accidentally sending in a number that would
+
+    // be interpreted as a start offset.
+
+    return typeof encoding === 'string'
+
+      ? createBuffer(size).fill(fill, encoding)
+
+      : createBuffer(size).fill(fill)
+
+  }
+
+  return createBuffer(size)
+
+}
+
+
+
+/**
+
+ * Creates a new filled Buffer instance.
+
+ * alloc(size[, fill[, encoding]])
+
+ **/
+
+Buffer.alloc = function (size, fill, encoding) {
+
+  return alloc(size, fill, encoding)
+
+}
+
+
+
+function allocUnsafe (size) {
+
+  assertSize(size)
+
+  return createBuffer(size < 0 ? 0 : checked(size) | 0)
+
+}
+
+
+
+/**
+
+ * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
+
+ * */
+
+Buffer.allocUnsafe = function (size) {
+
+  return allocUnsafe(size)
+
+}
+
+/**
+
+ * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
+
+ */
+
+Buffer.allocUnsafeSlow = function (size) {
+
+  return allocUnsafe(size)
+
+}
+
+
+
+function fromString (string, encoding) {
+
+  if (typeof encoding !== 'string' || encoding === '') {
+
+    encoding = 'utf8'
+
+  }
+
+
+
+  if (!Buffer.isEncoding(encoding)) {
+
+    throw new TypeError('Unknown encoding: ' + encoding)
+
+  }
+
+
+
+  const length = byteLength(string, encoding) | 0
+
+  let buf = createBuffer(length)
+
+
+
+  const actual = buf.write(string, encoding)
+
+
+
+  if (actual !== length) {
+
+    // Writing a hex string, for example, that contains invalid characters will
+
+    // cause everything after the first invalid character to be ignored. (e.g.
+
+    // 'abxxcd' will be treated as 'ab')
+
+    buf = buf.slice(0, actual)
+
+  }
+
+
+
+  return buf
+
+}
+
+
+
+function fromArrayLike (array) {
+
+  const length = array.length < 0 ? 0 : checked(array.length) | 0
+
+  const buf = createBuffer(length)
+
+  for (let i = 0; i < length; i += 1) {
+
+    buf[i] = array[i] & 255
+
+  }
+
+  return buf
+
+}
+
+
+
+function fromArrayView (arrayView) {
+
+  if (isInstance(arrayView, Uint8Array)) {
+
+    const copy = new Uint8Array(arrayView)
+
+    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
+
+  }
+
+  return fromArrayLike(arrayView)
+
+}
+
+
+
+function fromArrayBuffer (array, byteOffset, length) {
+
+  if (byteOffset < 0 || array.byteLength < byteOffset) {
+
+    throw new RangeError('"offset" is outside of buffer bounds')
+
+  }
+
+
+
+  if (array.byteLength < byteOffset + (length || 0)) {
+
+    throw new RangeError('"length" is outside of buffer bounds')
+
+  }
+
+
+
+  let buf
+
+  if (byteOffset === undefined && length === undefined) {
+
+    buf = new Uint8Array(array)
+
+  } else if (length === undefined) {
+
+    buf = new Uint8Array(array, byteOffset)
+
+  } else {
+
+    buf = new Uint8Array(array, byteOffset, length)
+
+  }
+
+
+
+  // Return an augmented `Uint8Array` instance
+
+  Object.setPrototypeOf(buf, Buffer.prototype)
+
+
+
+  return buf
+
+}
+
+
+
+function fromObject (obj) {
+
+  if (Buffer.isBuffer(obj)) {
+
+    const len = checked(obj.length) | 0
+
+    const buf = createBuffer(len)
+
+
+
+    if (buf.length === 0) {
+
+      return buf
+
+    }
+
+
+
+    obj.copy(buf, 0, 0, len)
+
+    return buf
+
+  }
+
+
+
+  if (obj.length !== undefined) {
+
+    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
+
+      return createBuffer(0)
+
+    }
+
+    return fromArrayLike(obj)
+
+  }
+
+
+
+  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
+
+    return fromArrayLike(obj.data)
+
+  }
+
+}
+
+
+
+function checked (length) {
+
+  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
+
+  // length is NaN (which is otherwise coerced to zero.)
+
+  if (length >= K_MAX_LENGTH) {
+
+    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
+
+                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
+
+  }
+
+  return length | 0
+
+}
+
+
+
+function SlowBuffer (length) {
+
+  if (+length != length) { // eslint-disable-line eqeqeq
+
+    length = 0
+
+  }
+
+  return Buffer.alloc(+length)
+
+}
+
+
+
+Buffer.isBuffer = function isBuffer (b) {
+
+  return b != null && b._isBuffer === true &&
+
+    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
+
+}
+
+
+
+Buffer.compare = function compare (a, b) {
+
+  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
+
+  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
+
+  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
+
+    throw new TypeError(
+
+      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
+
+    )
+
+  }
+
+
+
+  if (a === b) return 0
+
+
+
+  let x = a.length
+
+  let y = b.length
+
+
+
+  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
+
+    if (a[i] !== b[i]) {
+
+      x = a[i]
+
+      y = b[i]
+
+      break
+
+    }
+
+  }
+
+
+
+  if (x < y) return -1
+
+  if (y < x) return 1
+
+  return 0
+
+}
+
+
+
+Buffer.isEncoding = function isEncoding (encoding) {
+
+  switch (String(encoding).toLowerCase()) {
+
+    case 'hex':
+
+    case 'utf8':
+
+    case 'utf-8':
+
+    case 'ascii':
+
+    case 'latin1':
+
+    case 'binary':
+
+    case 'base64':
+
+    case 'ucs2':
+
+    case 'ucs-2':
+
+    case 'utf16le':
+
+    case 'utf-16le':
+
+      return true
+
+    default:
+
+      return false
+
+  }
+
+}
+
+
+
+Buffer.concat = function concat (list, length) {
+
+  if (!Array.isArray(list)) {
+
+    throw new TypeError('"list" argument must be an Array of Buffers')
+
+  }
+
+
+
+  if (list.length === 0) {
+
+    return Buffer.alloc(0)
+
+  }
+
+
+
+  let i
+
+  if (length === undefined) {
+
+    length = 0
+
+    for (i = 0; i < list.length; ++i) {
+
+      length += list[i].length
+
+    }
+
+  }
+
+
+
+  const buffer = Buffer.allocUnsafe(length)
+
+  let pos = 0
+
+  for (i = 0; i < list.length; ++i) {
+
+    let buf = list[i]
+
+    if (isInstance(buf, Uint8Array)) {
+
+      if (pos + buf.length > buffer.length) {
+
+        if (!Buffer.isBuffer(buf)) {
+
+          buf = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)
+
+        }
+
+        buf.copy(buffer, pos)
+
+      } else {
+
+        Uint8Array.prototype.set.call(
+
+          buffer,
+
+          buf,
+
+          pos
+
+        )
+
+      }
+
+    } else if (!Buffer.isBuffer(buf)) {
+
+      throw new TypeError('"list" argument must be an Array of Buffers')
+
+    } else {
+
+      buf.copy(buffer, pos)
+
+    }
+
+    pos += buf.length
+
+  }
+
+  return buffer
+
+}
+
+
+
+function byteLength (string, encoding) {
+
+  if (Buffer.isBuffer(string)) {
+
+    return string.length
+
+  }
+
+  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
+
+    return string.byteLength
+
+  }
+
+  if (typeof string !== 'string') {
+
+    throw new TypeError(
+
+      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
+
+      'Received type ' + typeof string
+
+    )
+
+  }
+
+
+
+  const len = string.length
+
+  const mustMatch = (arguments.length > 2 && arguments[2] === true)
+
+  if (!mustMatch && len === 0) return 0
+
+
+
+  // Use a for loop to avoid recursion
+
+  let loweredCase = false
+
+  for (;;) {
+
+    switch (encoding) {
+
+      case 'ascii':
+
+      case 'latin1':
+
+      case 'binary':
+
+        return len
+
+      case 'utf8':
+
+      case 'utf-8':
+
+        return utf8ToBytes(string).length
+
+      case 'ucs2':
+
+      case 'ucs-2':
+
+      case 'utf16le':
+
+      case 'utf-16le':
+
+        return len * 2
+
+      case 'hex':
+
+        return len >>> 1
+
+      case 'base64':
+
+        return base64ToBytes(string).length
+
+      default:
+
+        if (loweredCase) {
+
+          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
+
+        }
+
+        encoding = ('' + encoding).toLowerCase()
+
+        loweredCase = true
+
+    }
+
+  }
+
+}
+
+Buffer.byteLength = byteLength
+
+
+
+function slowToString (encoding, start, end) {
+
+  let loweredCase = false
+
+
+
+  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
+
+  // property of a typed array.
+
+
+
+  // This behaves neither like String nor Uint8Array in that we set start/end
+
+  // to their upper/lower bounds if the value passed is out of range.
+
+  // undefined is handled specially as per ECMA-262 6th Edition,
+
+  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
+
+  if (start === undefined || start < 0) {
+
+    start = 0
+
+  }
+
+  // Return early if start > this.length. Done here to prevent potential uint32
+
+  // coercion fail below.
+
+  if (start > this.length) {
+
+    return ''
+
+  }
+
+
+
+  if (end === undefined || end > this.length) {
+
+    end = this.length
+
+  }
+
+
+
+  if (end <= 0) {
+
+    return ''
+
+  }
+
+
+
+  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
+
+  end >>>= 0
+
+  start >>>= 0
+
+
+
+  if (end <= start) {
+
+    return ''
+
+  }
+
+
+
+  if (!encoding) encoding = 'utf8'
+
+
+
+  while (true) {
+
+    switch (encoding) {
+
+      case 'hex':
+
+        return hexSlice(this, start, end)
+
+
+
+      case 'utf8':
+
+      case 'utf-8':
+
+        return utf8Slice(this, start, end)
+
+
+
+      case 'ascii':
+
+        return asciiSlice(this, start, end)
+
+
+
+      case 'latin1':
+
+      case 'binary':
+
+        return latin1Slice(this, start, end)
+
+
+
+      case 'base64':
+
+        return base64Slice(this, start, end)
+
+
+
+      case 'ucs2':
+
+      case 'ucs-2':
+
+      case 'utf16le':
+
+      case 'utf-16le':
+
+        return utf16leSlice(this, start, end)
+
+
+
+      default:
+
+        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
+
+        encoding = (encoding + '').toLowerCase()
+
+        loweredCase = true
+
+    }
+
+  }
+
+}
+
+
+
+// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
+
+// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
+
+// reliably in a browserify context because there could be multiple different
+
+// copies of the 'buffer' package in use. This method works even for Buffer
+
+// instances that were created from another copy of the `buffer` package.
+
+// See: https://github.com/feross/buffer/issues/154
+
+Buffer.prototype._isBuffer = true
+
+
+
+function swap (b, n, m) {
+
+  const i = b[n]
+
+  b[n] = b[m]
+
+  b[m] = i
+
+}
+
+
+
+Buffer.prototype.swap16 = function swap16 () {
+
+  const len = this.length
+
+  if (len % 2 !== 0) {
+
+    throw new RangeError('Buffer size must be a multiple of 16-bits')
+
+  }
+
+  for (let i = 0; i < len; i += 2) {
+
+    swap(this, i, i + 1)
+
+  }
+
+  return this
+
+}
+
+
+
+Buffer.prototype.swap32 = function swap32 () {
+
+  const len = this.length
+
+  if (len % 4 !== 0) {
+
+    throw new RangeError('Buffer size must be a multiple of 32-bits')
+
+  }
+
+  for (let i = 0; i < len; i += 4) {
+
+    swap(this, i, i + 3)
+
+    swap(this, i + 1, i + 2)
+
+  }
+
+  return this
+
+}
+
+
+
+Buffer.prototype.swap64 = function swap64 () {
+
+  const len = this.length
+
+  if (len % 8 !== 0) {
+
+    throw new RangeError('Buffer size must be a multiple of 64-bits')
+
+  }
+
+  for (let i = 0; i < len; i += 8) {
+
+    swap(this, i, i + 7)
+
+    swap(this, i + 1, i + 6)
+
+    swap(this, i + 2, i + 5)
+
+    swap(this, i + 3, i + 4)
+
+  }
+
+  return this
+
+}
+
+
+
+Buffer.prototype.toString = function toString () {
+
+  const length = this.length
+
+  if (length === 0) return ''
+
+  if (arguments.length === 0) return utf8Slice(this, 0, length)
+
+  return slowToString.apply(this, arguments)
+
+}
+
+
+
+Buffer.prototype.toLocaleString = Buffer.prototype.toString
+
+
+
+Buffer.prototype.equals = function equals (b) {
+
+  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
+
+  if (this === b) return true
+
+  return Buffer.compare(this, b) === 0
+
+}
+
+
+
+Buffer.prototype.inspect = function inspect () {
+
+  let str = ''
+
+  const max = exports.INSPECT_MAX_BYTES
+
+  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
+
+  if (this.length > max) str += ' ... '
+
+  return '<Buffer ' + str + '>'
+
+}
+
+if (customInspectSymbol) {
+
+  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
+
+}
+
+
+
+Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
+
+  if (isInstance(target, Uint8Array)) {
+
+    target = Buffer.from(target, target.offset, target.byteLength)
+
+  }
+
+  if (!Buffer.isBuffer(target)) {
+
+    throw new TypeError(
+
+      'The "target" argument must be one of type Buffer or Uint8Array. ' +
+
+      'Received type ' + (typeof target)
+
+    )
+
+  }
+
+
+
+  if (start === undefined) {
+
+    start = 0
+
+  }
+
+  if (end === undefined) {
+
+    end = target ? target.length : 0
+
+  }
+
+  if (thisStart === undefined) {
+
+    thisStart = 0
+
+  }
+
+  if (thisEnd === undefined) {
+
+    thisEnd = this.length
+
+  }
+
+
+
+  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
+
+    throw new RangeError('out of range index')
+
+  }
+
+
+
+  if (thisStart >= thisEnd && start >= end) {
+
+    return 0
+
+  }
+
+  if (thisStart >= thisEnd) {
+
+    return -1
+
+  }
+
+  if (start >= end) {
+
+    return 1
+
+  }
+
+
+
+  start >>>= 0
+
+  end >>>= 0
+
+  thisStart >>>= 0
+
+  thisEnd >>>= 0
+
+
+
+  if (this === target) return 0
+
+
+
+  let x = thisEnd - thisStart
+
+  let y = end - start
+
+  const len = Math.min(x, y)
+
+
+
+  const thisCopy = this.slice(thisStart, thisEnd)
+
+  const targetCopy = target.slice(start, end)
+
+
+
+  for (let i = 0; i < len; ++i) {
+
+    if (thisCopy[i] !== targetCopy[i]) {
+
+      x = thisCopy[i]
+
+      y = targetCopy[i]
+
+      break
+
+    }
+
+  }
+
+
+
+  if (x < y) return -1
+
+  if (y < x) return 1
+
+  return 0
+
+}
+
+
+
+// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
+
+// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
+
+//
+
+// Arguments:
+
+// - buffer - a Buffer to search
+
+// - val - a string, Buffer, or number
+
+// - byteOffset - an index into `buffer`; will be clamped to an int32
+
+// - encoding - an optional encoding, relevant is val is a string
+
+// - dir - true for indexOf, false for lastIndexOf
+
+function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
+
+  // Empty buffer means no match
+
+  if (buffer.length === 0) return -1
+
+
+
+  // Normalize byteOffset
+
+  if (typeof byteOffset === 'string') {
+
+    encoding = byteOffset
+
+    byteOffset = 0
+
+  } else if (byteOffset > 0x7fffffff) {
+
+    byteOffset = 0x7fffffff
+
+  } else if (byteOffset < -0x80000000) {
+
+    byteOffset = -0x80000000
+
+  }
+
+  byteOffset = +byteOffset // Coerce to Number.
+
+  if (numberIsNaN(byteOffset)) {
+
+    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
+
+    byteOffset = dir ? 0 : (buffer.length - 1)
+
+  }
+
+
+
+  // Normalize byteOffset: negative offsets start from the end of the buffer
+
+  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
+
+  if (byteOffset >= buffer.length) {
+
+    if (dir) return -1
+
+    else byteOffset = buffer.length - 1
+
+  } else if (byteOffset < 0) {
+
+    if (dir) byteOffset = 0
+
+    else return -1
+
+  }
+
+
+
+  // Normalize val
+
+  if (typeof val === 'string') {
+
+    val = Buffer.from(val, encoding)
+
+  }
+
+
+
+  // Finally, search either indexOf (if dir is true) or lastIndexOf
+
+  if (Buffer.isBuffer(val)) {
+
+    // Special case: looking for empty string/buffer always fails
+
+    if (val.length === 0) {
+
+      return -1
+
+    }
+
+    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
+
+  } else if (typeof val === 'number') {
+
+    val = val & 0xFF // Search for a byte value [0-255]
+
+    if (typeof Uint8Array.prototype.indexOf === 'function') {
+
+      if (dir) {
+
+        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
+
+      } else {
+
+        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
+
+      }
+
+    }
+
+    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
+
+  }
+
+
+
+  throw new TypeError('val must be string, number or Buffer')
+
+}
+
+
+
+function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
+
+  let indexSize = 1
+
+  let arrLength = arr.length
+
+  let valLength = val.length
+
+
+
+  if (encoding !== undefined) {
+
+    encoding = String(encoding).toLowerCase()
+
+    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
+
+        encoding === 'utf16le' || encoding === 'utf-16le') {
+
+      if (arr.length < 2 || val.length < 2) {
+
+        return -1
+
+      }
+
+      indexSize = 2
+
+      arrLength /= 2
+
+      valLength /= 2
+
+      byteOffset /= 2
+
+    }
+
+  }
+
+
+
+  function read (buf, i) {
+
+    if (indexSize === 1) {
+
+      return buf[i]
+
+    } else {
+
+      return buf.readUInt16BE(i * indexSize)
+
+    }
+
+  }
+
+
+
+  let i
+
+  if (dir) {
+
+    let foundIndex = -1
+
+    for (i = byteOffset; i < arrLength; i++) {
+
+      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
+
+        if (foundIndex === -1) foundIndex = i
+
+        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
+
+      } else {
+
+        if (foundIndex !== -1) i -= i - foundIndex
+
+        foundIndex = -1
+
+      }
+
+    }
+
+  } else {
+
+    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
+
+    for (i = byteOffset; i >= 0; i--) {
+
+      let found = true
+
+      for (let j = 0; j < valLength; j++) {
+
+        if (read(arr, i + j) !== read(val, j)) {
+
+          found = false
+
+          break
+
+        }
+
+      }
+
+      if (found) return i
+
+    }
+
+  }
+
+
+
+  return -1
+
+}
+
+
+
+Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
+
+  return this.indexOf(val, byteOffset, encoding) !== -1
+
+}
+
+
+
+Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
+
+  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
+
+}
+
+
+
+Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
+
+  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
+
+}
+
+
+
+function hexWrite (buf, string, offset, length) {
+
+  offset = Number(offset) || 0
+
+  const remaining = buf.length - offset
+
+  if (!length) {
+
+    length = remaining
+
+  } else {
+
+    length = Number(length)
+
+    if (length > remaining) {
+
+      length = remaining
+
+    }
+
+  }
+
+
+
+  const strLen = string.length
+
+
+
+  if (length > strLen / 2) {
+
+    length = strLen / 2
+
+  }
+
+  let i
+
+  for (i = 0; i < length; ++i) {
+
+    const parsed = parseInt(string.substr(i * 2, 2), 16)
+
+    if (numberIsNaN(parsed)) return i
+
+    buf[offset + i] = parsed
+
+  }
+
+  return i
+
+}
+
+
+
+function utf8Write (buf, string, offset, length) {
+
+  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
+
+}
+
+
+
+function asciiWrite (buf, string, offset, length) {
+
+  return blitBuffer(asciiToBytes(string), buf, offset, length)
+
+}
+
+
+
+function base64Write (buf, string, offset, length) {
+
+  return blitBuffer(base64ToBytes(string), buf, offset, length)
+
+}
+
+
+
+function ucs2Write (buf, string, offset, length) {
+
+  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
+
+}
+
+
+
+Buffer.prototype.write = function write (string, offset, length, encoding) {
+
+  // Buffer#write(string)
+
+  if (offset === undefined) {
+
+    encoding = 'utf8'
+
+    length = this.length
+
+    offset = 0
+
+  // Buffer#write(string, encoding)
+
+  } else if (length === undefined && typeof offset === 'string') {
+
+    encoding = offset
+
+    length = this.length
+
+    offset = 0
+
+  // Buffer#write(string, offset[, length][, encoding])
+
+  } else if (isFinite(offset)) {
+
+    offset = offset >>> 0
+
+    if (isFinite(length)) {
+
+      length = length >>> 0
+
+      if (encoding === undefined) encoding = 'utf8'
+
+    } else {
+
+      encoding = length
+
+      length = undefined
+
+    }
+
+  } else {
+
+    throw new Error(
+
+      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
+
+    )
+
+  }
+
+
+
+  const remaining = this.length - offset
+
+  if (length === undefined || length > remaining) length = remaining
+
+
+
+  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
+
+    throw new RangeError('Attempt to write outside buffer bounds')
+
+  }
+
+
+
+  if (!encoding) encoding = 'utf8'
+
+
+
+  let loweredCase = false
+
+  for (;;) {
+
+    switch (encoding) {
+
+      case 'hex':
+
+        return hexWrite(this, string, offset, length)
+
+
+
+      case 'utf8':
+
+      case 'utf-8':
+
+        return utf8Write(this, string, offset, length)
+
+
+
+      case 'ascii':
+
+      case 'latin1':
+
+      case 'binary':
+
+        return asciiWrite(this, string, offset, length)
+
+
+
+      case 'base64':
+
+        // Warning: maxLength not taken into account in base64Write
+
+        return base64Write(this, string, offset, length)
+
+
+
+      case 'ucs2':
+
+      case 'ucs-2':
+
+      case 'utf16le':
+
+      case 'utf-16le':
+
+        return ucs2Write(this, string, offset, length)
+
+
+
+      default:
+
+        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
+
+        encoding = ('' + encoding).toLowerCase()
+
+        loweredCase = true
+
+    }
+
+  }
+
+}
+
+
+
+Buffer.prototype.toJSON = function toJSON () {
+
+  return {
+
+    type: 'Buffer',
+
+    data: Array.prototype.slice.call(this._arr || this, 0)
+
+  }
+
+}
+
+
+
+function base64Slice (buf, start, end) {
+
+  if (start === 0 && end === buf.length) {
+
+    return base64.fromByteArray(buf)
+
+  } else {
+
+    return base64.fromByteArray(buf.slice(start, end))
+
+  }
+
+}
+
+
+
+function utf8Slice (buf, start, end) {
+
+  end = Math.min(buf.length, end)
+
+  const res = []
+
+
+
+  let i = start
+
+  while (i < end) {
+
+    const firstByte = buf[i]
+
+    let codePoint = null
+
+    let bytesPerSequence = (firstByte > 0xEF)
+
+      ? 4
+
+      : (firstByte > 0xDF)
+
+          ? 3
+
+          : (firstByte > 0xBF)
+
+              ? 2
+
+              : 1
+
+
+
+    if (i + bytesPerSequence <= end) {
+
+      let secondByte, thirdByte, fourthByte, tempCodePoint
+
+
+
+      switch (bytesPerSequence) {
+
+        case 1:
+
+          if (firstByte < 0x80) {
+
+            codePoint = firstByte
+
+          }
+
+          break
+
+        case 2:
+
+          secondByte = buf[i + 1]
+
+          if ((secondByte & 0xC0) === 0x80) {
+
+            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
+
+            if (tempCodePoint > 0x7F) {
+
+              codePoint = tempCodePoint
+
+            }
+
+          }
+
+          break
+
+        case 3:
+
+          secondByte = buf[i + 1]
+
+          thirdByte = buf[i + 2]
+
+          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
+
+            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
+
+            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
+
+              codePoint = tempCodePoint
+
+            }
+
+          }
+
+          break
+
+        case 4:
+
+          secondByte = buf[i + 1]
+
+          thirdByte = buf[i + 2]
+
+          fourthByte = buf[i + 3]
+
+          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
+
+            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
+
+            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
+
+              codePoint = tempCodePoint
+
+            }
+
+          }
+
+      }
+
+    }
+
+
+
+    if (codePoint === null) {
+
+      // we did not generate a valid codePoint so insert a
+
+      // replacement char (U+FFFD) and advance only 1 byte
+
+      codePoint = 0xFFFD
+
+      bytesPerSequence = 1
+
+    } else if (codePoint > 0xFFFF) {
+
+      // encode to utf16 (surrogate pair dance)
+
+      codePoint -= 0x10000
+
+      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
+
+      codePoint = 0xDC00 | codePoint & 0x3FF
+
+    }
+
+
+
+    res.push(codePoint)
+
+    i += bytesPerSequence
+
+  }
+
+
+
+  return decodeCodePointsArray(res)
+
+}
+
+
+
+// Based on http://stackoverflow.com/a/22747272/680742, the browser with
+
+// the lowest limit is Chrome, with 0x10000 args.
+
+// We go 1 magnitude less, for safety
+
+const MAX_ARGUMENTS_LENGTH = 0x1000
+
+
+
+function decodeCodePointsArray (codePoints) {
+
+  const len = codePoints.length
+
+  if (len <= MAX_ARGUMENTS_LENGTH) {
+
+    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
+
+  }
+
+
+
+  // Decode in chunks to avoid "call stack size exceeded".
+
+  let res = ''
+
+  let i = 0
+
+  while (i < len) {
+
+    res += String.fromCharCode.apply(
+
+      String,
+
+      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
+
+    )
+
+  }
+
+  return res
+
+}
+
+
+
+function asciiSlice (buf, start, end) {
+
+  let ret = ''
+
+  end = Math.min(buf.length, end)
+
+
+
+  for (let i = start; i < end; ++i) {
+
+    ret += String.fromCharCode(buf[i] & 0x7F)
+
+  }
+
+  return ret
+
+}
+
+
+
+function latin1Slice (buf, start, end) {
+
+  let ret = ''
+
+  end = Math.min(buf.length, end)
+
+
+
+  for (let i = start; i < end; ++i) {
+
+    ret += String.fromCharCode(buf[i])
+
+  }
+
+  return ret
+
+}
+
+
+
+function hexSlice (buf, start, end) {
+
+  const len = buf.length
+
+
+
+  if (!start || start < 0) start = 0
+
+  if (!end || end < 0 || end > len) end = len
+
+
+
+  let out = ''
+
+  for (let i = start; i < end; ++i) {
+
+    out += hexSliceLookupTable[buf[i]]
+
+  }
+
+  return out
+
+}
+
+
+
+function utf16leSlice (buf, start, end) {
+
+  const bytes = buf.slice(start, end)
+
+  let res = ''
+
+  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
+
+  for (let i = 0; i < bytes.length - 1; i += 2) {
+
+    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
+
+  }
+
+  return res
+
+}
+
+
+
+Buffer.prototype.slice = function slice (start, end) {
+
+  const len = this.length
+
+  start = ~~start
+
+  end = end === undefined ? len : ~~end
+
+
+
+  if (start < 0) {
+
+    start += len
+
+    if (start < 0) start = 0
+
+  } else if (start > len) {
+
+    start = len
+
+  }
+
+
+
+  if (end < 0) {
+
+    end += len
+
+    if (end < 0) end = 0
+
+  } else if (end > len) {
+
+    end = len
+
+  }
+
+
+
+  if (end < start) end = start
+
+
+
+  const newBuf = this.subarray(start, end)
+
+  // Return an augmented `Uint8Array` instance
+
+  Object.setPrototypeOf(newBuf, Buffer.prototype)
+
+
+
+  return newBuf
+
+}
+
+
+
+/*
+
+ * Need to make sure that buffer isn't trying to write out of bounds.
+
+ */
+
+function checkOffset (offset, ext, length) {
+
+  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
+
+  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
+
+}
+
+
+
+Buffer.prototype.readUintLE =
+
+Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
+
+  offset = offset >>> 0
+
+  byteLength = byteLength >>> 0
+
+  if (!noAssert) checkOffset(offset, byteLength, this.length)
+
+
+
+  let val = this[offset]
+
+  let mul = 1
+
+  let i = 0
+
+  while (++i < byteLength && (mul *= 0x100)) {
+
+    val += this[offset + i] * mul
+
+  }
+
+
+
+  return val
+
+}
+
+
+
+Buffer.prototype.readUintBE =
+
+Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
+
+  offset = offset >>> 0
+
+  byteLength = byteLength >>> 0
+
+  if (!noAssert) {
+
+    checkOffset(offset, byteLength, this.length)
+
+  }
+
+
+
+  let val = this[offset + --byteLength]
+
+  let mul = 1
+
+  while (byteLength > 0 && (mul *= 0x100)) {
+
+    val += this[offset + --byteLength] * mul
+
+  }
+
+
+
+  return val
+
+}
+
+
+
+Buffer.prototype.readUint8 =
+
+Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 1, this.length)
+
+  return this[offset]
+
+}
+
+
+
+Buffer.prototype.readUint16LE =
+
+Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 2, this.length)
+
+  return this[offset] | (this[offset + 1] << 8)
+
+}
+
+
+
+Buffer.prototype.readUint16BE =
+
+Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 2, this.length)
+
+  return (this[offset] << 8) | this[offset + 1]
+
+}
+
+
+
+Buffer.prototype.readUint32LE =
+
+Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+
+
+  return ((this[offset]) |
+
+      (this[offset + 1] << 8) |
+
+      (this[offset + 2] << 16)) +
+
+      (this[offset + 3] * 0x1000000)
+
+}
+
+
+
+Buffer.prototype.readUint32BE =
+
+Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+
+
+  return (this[offset] * 0x1000000) +
+
+    ((this[offset + 1] << 16) |
+
+    (this[offset + 2] << 8) |
+
+    this[offset + 3])
+
+}
+
+
+
+Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
+
+  offset = offset >>> 0
+
+  validateNumber(offset, 'offset')
+
+  const first = this[offset]
+
+  const last = this[offset + 7]
+
+  if (first === undefined || last === undefined) {
+
+    boundsError(offset, this.length - 8)
+
+  }
+
+
+
+  const lo = first +
+
+    this[++offset] * 2 ** 8 +
+
+    this[++offset] * 2 ** 16 +
+
+    this[++offset] * 2 ** 24
+
+
+
+  const hi = this[++offset] +
+
+    this[++offset] * 2 ** 8 +
+
+    this[++offset] * 2 ** 16 +
+
+    last * 2 ** 24
+
+
+
+  return BigInt(lo) + (BigInt(hi) << BigInt(32))
+
+})
+
+
+
+Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
+
+  offset = offset >>> 0
+
+  validateNumber(offset, 'offset')
+
+  const first = this[offset]
+
+  const last = this[offset + 7]
+
+  if (first === undefined || last === undefined) {
+
+    boundsError(offset, this.length - 8)
+
+  }
+
+
+
+  const hi = first * 2 ** 24 +
+
+    this[++offset] * 2 ** 16 +
+
+    this[++offset] * 2 ** 8 +
+
+    this[++offset]
+
+
+
+  const lo = this[++offset] * 2 ** 24 +
+
+    this[++offset] * 2 ** 16 +
+
+    this[++offset] * 2 ** 8 +
+
+    last
+
+
+
+  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
+
+})
+
+
+
+Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
+
+  offset = offset >>> 0
+
+  byteLength = byteLength >>> 0
+
+  if (!noAssert) checkOffset(offset, byteLength, this.length)
+
+
+
+  let val = this[offset]
+
+  let mul = 1
+
+  let i = 0
+
+  while (++i < byteLength && (mul *= 0x100)) {
+
+    val += this[offset + i] * mul
+
+  }
+
+  mul *= 0x80
+
+
+
+  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
+
+
+
+  return val
+
+}
+
+
+
+Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
+
+  offset = offset >>> 0
+
+  byteLength = byteLength >>> 0
+
+  if (!noAssert) checkOffset(offset, byteLength, this.length)
+
+
+
+  let i = byteLength
+
+  let mul = 1
+
+  let val = this[offset + --i]
+
+  while (i > 0 && (mul *= 0x100)) {
+
+    val += this[offset + --i] * mul
+
+  }
+
+  mul *= 0x80
+
+
+
+  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
+
+
+
+  return val
+
+}
+
+
+
+Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 1, this.length)
+
+  if (!(this[offset] & 0x80)) return (this[offset])
+
+  return ((0xff - this[offset] + 1) * -1)
+
+}
+
+
+
+Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 2, this.length)
+
+  const val = this[offset] | (this[offset + 1] << 8)
+
+  return (val & 0x8000) ? val | 0xFFFF0000 : val
+
+}
+
+
+
+Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 2, this.length)
+
+  const val = this[offset + 1] | (this[offset] << 8)
+
+  return (val & 0x8000) ? val | 0xFFFF0000 : val
+
+}
+
+
+
+Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+
+
+  return (this[offset]) |
+
+    (this[offset + 1] << 8) |
+
+    (this[offset + 2] << 16) |
+
+    (this[offset + 3] << 24)
+
+}
+
+
+
+Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+
+
+  return (this[offset] << 24) |
+
+    (this[offset + 1] << 16) |
+
+    (this[offset + 2] << 8) |
+
+    (this[offset + 3])
+
+}
+
+
+
+Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
+
+  offset = offset >>> 0
+
+  validateNumber(offset, 'offset')
+
+  const first = this[offset]
+
+  const last = this[offset + 7]
+
+  if (first === undefined || last === undefined) {
+
+    boundsError(offset, this.length - 8)
+
+  }
+
+
+
+  const val = this[offset + 4] +
+
+    this[offset + 5] * 2 ** 8 +
+
+    this[offset + 6] * 2 ** 16 +
+
+    (last << 24) // Overflow
+
+
+
+  return (BigInt(val) << BigInt(32)) +
+
+    BigInt(first +
+
+    this[++offset] * 2 ** 8 +
+
+    this[++offset] * 2 ** 16 +
+
+    this[++offset] * 2 ** 24)
+
+})
+
+
+
+Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
+
+  offset = offset >>> 0
+
+  validateNumber(offset, 'offset')
+
+  const first = this[offset]
+
+  const last = this[offset + 7]
+
+  if (first === undefined || last === undefined) {
+
+    boundsError(offset, this.length - 8)
+
+  }
+
+
+
+  const val = (first << 24) + // Overflow
+
+    this[++offset] * 2 ** 16 +
+
+    this[++offset] * 2 ** 8 +
+
+    this[++offset]
+
+
+
+  return (BigInt(val) << BigInt(32)) +
+
+    BigInt(this[++offset] * 2 ** 24 +
+
+    this[++offset] * 2 ** 16 +
+
+    this[++offset] * 2 ** 8 +
+
+    last)
+
+})
+
+
+
+Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+  return ieee754.read(this, offset, true, 23, 4)
+
+}
+
+
+
+Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+  return ieee754.read(this, offset, false, 23, 4)
+
+}
+
+
+
+Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 8, this.length)
+
+  return ieee754.read(this, offset, true, 52, 8)
+
+}
+
+
+
+Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkOffset(offset, 8, this.length)
+
+  return ieee754.read(this, offset, false, 52, 8)
+
+}
+
+
+
+function checkInt (buf, value, offset, ext, max, min) {
+
+  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
+
+  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
+
+  if (offset + ext > buf.length) throw new RangeError('Index out of range')
+
+}
+
+
+
+Buffer.prototype.writeUintLE =
+
+Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  byteLength = byteLength >>> 0
+
+  if (!noAssert) {
+
+    const maxBytes = Math.pow(2, 8 * byteLength) - 1
+
+    checkInt(this, value, offset, byteLength, maxBytes, 0)
+
+  }
+
+
+
+  let mul = 1
+
+  let i = 0
+
+  this[offset] = value & 0xFF
+
+  while (++i < byteLength && (mul *= 0x100)) {
+
+    this[offset + i] = (value / mul) & 0xFF
+
+  }
+
+
+
+  return offset + byteLength
+
+}
+
+
+
+Buffer.prototype.writeUintBE =
+
+Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  byteLength = byteLength >>> 0
+
+  if (!noAssert) {
+
+    const maxBytes = Math.pow(2, 8 * byteLength) - 1
+
+    checkInt(this, value, offset, byteLength, maxBytes, 0)
+
+  }
+
+
+
+  let i = byteLength - 1
+
+  let mul = 1
+
+  this[offset + i] = value & 0xFF
+
+  while (--i >= 0 && (mul *= 0x100)) {
+
+    this[offset + i] = (value / mul) & 0xFF
+
+  }
+
+
+
+  return offset + byteLength
+
+}
+
+
+
+Buffer.prototype.writeUint8 =
+
+Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
+
+  this[offset] = (value & 0xff)
+
+  return offset + 1
+
+}
+
+
+
+Buffer.prototype.writeUint16LE =
+
+Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
+
+  this[offset] = (value & 0xff)
+
+  this[offset + 1] = (value >>> 8)
+
+  return offset + 2
+
+}
+
+
+
+Buffer.prototype.writeUint16BE =
+
+Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
+
+  this[offset] = (value >>> 8)
+
+  this[offset + 1] = (value & 0xff)
+
+  return offset + 2
+
+}
+
+
+
+Buffer.prototype.writeUint32LE =
+
+Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
+
+  this[offset + 3] = (value >>> 24)
+
+  this[offset + 2] = (value >>> 16)
+
+  this[offset + 1] = (value >>> 8)
+
+  this[offset] = (value & 0xff)
+
+  return offset + 4
+
+}
+
+
+
+Buffer.prototype.writeUint32BE =
+
+Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
+
+  this[offset] = (value >>> 24)
+
+  this[offset + 1] = (value >>> 16)
+
+  this[offset + 2] = (value >>> 8)
+
+  this[offset + 3] = (value & 0xff)
+
+  return offset + 4
+
+}
+
+
+
+function wrtBigUInt64LE (buf, value, offset, min, max) {
+
+  checkIntBI(value, min, max, buf, offset, 7)
+
+
+
+  let lo = Number(value & BigInt(0xffffffff))
+
+  buf[offset++] = lo
+
+  lo = lo >> 8
+
+  buf[offset++] = lo
+
+  lo = lo >> 8
+
+  buf[offset++] = lo
+
+  lo = lo >> 8
+
+  buf[offset++] = lo
+
+  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
+
+  buf[offset++] = hi
+
+  hi = hi >> 8
+
+  buf[offset++] = hi
+
+  hi = hi >> 8
+
+  buf[offset++] = hi
+
+  hi = hi >> 8
+
+  buf[offset++] = hi
+
+  return offset
+
+}
+
+
+
+function wrtBigUInt64BE (buf, value, offset, min, max) {
+
+  checkIntBI(value, min, max, buf, offset, 7)
+
+
+
+  let lo = Number(value & BigInt(0xffffffff))
+
+  buf[offset + 7] = lo
+
+  lo = lo >> 8
+
+  buf[offset + 6] = lo
+
+  lo = lo >> 8
+
+  buf[offset + 5] = lo
+
+  lo = lo >> 8
+
+  buf[offset + 4] = lo
+
+  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
+
+  buf[offset + 3] = hi
+
+  hi = hi >> 8
+
+  buf[offset + 2] = hi
+
+  hi = hi >> 8
+
+  buf[offset + 1] = hi
+
+  hi = hi >> 8
+
+  buf[offset] = hi
+
+  return offset + 8
+
+}
+
+
+
+Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
+
+  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
+
+})
+
+
+
+Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
+
+  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
+
+})
+
+
+
+Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) {
+
+    const limit = Math.pow(2, (8 * byteLength) - 1)
+
+
+
+    checkInt(this, value, offset, byteLength, limit - 1, -limit)
+
+  }
+
+
+
+  let i = 0
+
+  let mul = 1
+
+  let sub = 0
+
+  this[offset] = value & 0xFF
+
+  while (++i < byteLength && (mul *= 0x100)) {
+
+    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
+
+      sub = 1
+
+    }
+
+    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
+
+  }
+
+
+
+  return offset + byteLength
+
+}
+
+
+
+Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) {
+
+    const limit = Math.pow(2, (8 * byteLength) - 1)
+
+
+
+    checkInt(this, value, offset, byteLength, limit - 1, -limit)
+
+  }
+
+
+
+  let i = byteLength - 1
+
+  let mul = 1
+
+  let sub = 0
+
+  this[offset + i] = value & 0xFF
+
+  while (--i >= 0 && (mul *= 0x100)) {
+
+    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
+
+      sub = 1
+
+    }
+
+    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
+
+  }
+
+
+
+  return offset + byteLength
+
+}
+
+
+
+Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
+
+  if (value < 0) value = 0xff + value + 1
+
+  this[offset] = (value & 0xff)
+
+  return offset + 1
+
+}
+
+
+
+Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
+
+  this[offset] = (value & 0xff)
+
+  this[offset + 1] = (value >>> 8)
+
+  return offset + 2
+
+}
+
+
+
+Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
+
+  this[offset] = (value >>> 8)
+
+  this[offset + 1] = (value & 0xff)
+
+  return offset + 2
+
+}
+
+
+
+Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
+
+  this[offset] = (value & 0xff)
+
+  this[offset + 1] = (value >>> 8)
+
+  this[offset + 2] = (value >>> 16)
+
+  this[offset + 3] = (value >>> 24)
+
+  return offset + 4
+
+}
+
+
+
+Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
+
+  if (value < 0) value = 0xffffffff + value + 1
+
+  this[offset] = (value >>> 24)
+
+  this[offset + 1] = (value >>> 16)
+
+  this[offset + 2] = (value >>> 8)
+
+  this[offset + 3] = (value & 0xff)
+
+  return offset + 4
+
+}
+
+
+
+Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
+
+  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
+
+})
+
+
+
+Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
+
+  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
+
+})
+
+
+
+function checkIEEE754 (buf, value, offset, ext, max, min) {
+
+  if (offset + ext > buf.length) throw new RangeError('Index out of range')
+
+  if (offset < 0) throw new RangeError('Index out of range')
+
+}
+
+
+
+function writeFloat (buf, value, offset, littleEndian, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) {
+
+    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
+
+  }
+
+  ieee754.write(buf, value, offset, littleEndian, 23, 4)
+
+  return offset + 4
+
+}
+
+
+
+Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
+
+  return writeFloat(this, value, offset, true, noAssert)
+
+}
+
+
+
+Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
+
+  return writeFloat(this, value, offset, false, noAssert)
+
+}
+
+
+
+function writeDouble (buf, value, offset, littleEndian, noAssert) {
+
+  value = +value
+
+  offset = offset >>> 0
+
+  if (!noAssert) {
+
+    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
+
+  }
+
+  ieee754.write(buf, value, offset, littleEndian, 52, 8)
+
+  return offset + 8
+
+}
+
+
+
+Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
+
+  return writeDouble(this, value, offset, true, noAssert)
+
+}
+
+
+
+Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
+
+  return writeDouble(this, value, offset, false, noAssert)
+
+}
+
+
+
+// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
+
+Buffer.prototype.copy = function copy (target, targetStart, start, end) {
+
+  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
+
+  if (!start) start = 0
+
+  if (!end && end !== 0) end = this.length
+
+  if (targetStart >= target.length) targetStart = target.length
+
+  if (!targetStart) targetStart = 0
+
+  if (end > 0 && end < start) end = start
+
+
+
+  // Copy 0 bytes; we're done
+
+  if (end === start) return 0
+
+  if (target.length === 0 || this.length === 0) return 0
+
+
+
+  // Fatal error conditions
+
+  if (targetStart < 0) {
+
+    throw new RangeError('targetStart out of bounds')
+
+  }
+
+  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
+
+  if (end < 0) throw new RangeError('sourceEnd out of bounds')
+
+
+
+  // Are we oob?
+
+  if (end > this.length) end = this.length
+
+  if (target.length - targetStart < end - start) {
+
+    end = target.length - targetStart + start
+
+  }
+
+
+
+  const len = end - start
+
+
+
+  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
+
+    // Use built-in when available, missing from IE11
+
+    this.copyWithin(targetStart, start, end)
+
+  } else {
+
+    Uint8Array.prototype.set.call(
+
+      target,
+
+      this.subarray(start, end),
+
+      targetStart
+
+    )
+
+  }
+
+
+
+  return len
+
+}
+
+
+
+// Usage:
+
+//    buffer.fill(number[, offset[, end]])
+
+//    buffer.fill(buffer[, offset[, end]])
+
+//    buffer.fill(string[, offset[, end]][, encoding])
+
+Buffer.prototype.fill = function fill (val, start, end, encoding) {
+
+  // Handle string cases:
+
+  if (typeof val === 'string') {
+
+    if (typeof start === 'string') {
+
+      encoding = start
+
+      start = 0
+
+      end = this.length
+
+    } else if (typeof end === 'string') {
+
+      encoding = end
+
+      end = this.length
+
+    }
+
+    if (encoding !== undefined && typeof encoding !== 'string') {
+
+      throw new TypeError('encoding must be a string')
+
+    }
+
+    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
+
+      throw new TypeError('Unknown encoding: ' + encoding)
+
+    }
+
+    if (val.length === 1) {
+
+      const code = val.charCodeAt(0)
+
+      if ((encoding === 'utf8' && code < 128) ||
+
+          encoding === 'latin1') {
+
+        // Fast path: If `val` fits into a single byte, use that numeric value.
+
+        val = code
+
+      }
+
+    }
+
+  } else if (typeof val === 'number') {
+
+    val = val & 255
+
+  } else if (typeof val === 'boolean') {
+
+    val = Number(val)
+
+  }
+
+
+
+  // Invalid ranges are not set to a default, so can range check early.
+
+  if (start < 0 || this.length < start || this.length < end) {
+
+    throw new RangeError('Out of range index')
+
+  }
+
+
+
+  if (end <= start) {
+
+    return this
+
+  }
+
+
+
+  start = start >>> 0
+
+  end = end === undefined ? this.length : end >>> 0
+
+
+
+  if (!val) val = 0
+
+
+
+  let i
+
+  if (typeof val === 'number') {
+
+    for (i = start; i < end; ++i) {
+
+      this[i] = val
+
+    }
+
+  } else {
+
+    const bytes = Buffer.isBuffer(val)
+
+      ? val
+
+      : Buffer.from(val, encoding)
+
+    const len = bytes.length
+
+    if (len === 0) {
+
+      throw new TypeError('The value "' + val +
+
+        '" is invalid for argument "value"')
+
+    }
+
+    for (i = 0; i < end - start; ++i) {
+
+      this[i + start] = bytes[i % len]
+
+    }
+
+  }
+
+
+
+  return this
+
+}
+
+
+
+// CUSTOM ERRORS
+
+// =============
+
+
+
+// Simplified versions from Node, changed for Buffer-only usage
+
+const errors = {}
+
+function E (sym, getMessage, Base) {
+
+  errors[sym] = class NodeError extends Base {
+
+    constructor () {
+
+      super()
+
+
+
+      Object.defineProperty(this, 'message', {
+
+        value: getMessage.apply(this, arguments),
+
+        writable: true,
+
+        configurable: true
+
+      })
+
+
+
+      // Add the error code to the name to include it in the stack trace.
+
+      this.name = `${this.name} [${sym}]`
+
+      // Access the stack to generate the error message including the error code
+
+      // from the name.
+
+      this.stack // eslint-disable-line no-unused-expressions
+
+      // Reset the name to the actual name.
+
+      delete this.name
+
+    }
+
+
+
+    get code () {
+
+      return sym
+
+    }
+
+
+
+    set code (value) {
+
+      Object.defineProperty(this, 'code', {
+
+        configurable: true,
+
+        enumerable: true,
+
+        value,
+
+        writable: true
+
+      })
+
+    }
+
+
+
+    toString () {
+
+      return `${this.name} [${sym}]: ${this.message}`
+
+    }
+
+  }
+
+}
+
+
+
+E('ERR_BUFFER_OUT_OF_BOUNDS',
+
+  function (name) {
+
+    if (name) {
+
+      return `${name} is outside of buffer bounds`
+
+    }
+
+
+
+    return 'Attempt to access memory outside buffer bounds'
+
+  }, RangeError)
+
+E('ERR_INVALID_ARG_TYPE',
+
+  function (name, actual) {
+
+    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
+
+  }, TypeError)
+
+E('ERR_OUT_OF_RANGE',
+
+  function (str, range, input) {
+
+    let msg = `The value of "${str}" is out of range.`
+
+    let received = input
+
+    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
+
+      received = addNumericalSeparator(String(input))
+
+    } else if (typeof input === 'bigint') {
+
+      received = String(input)
+
+      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
+
+        received = addNumericalSeparator(received)
+
+      }
+
+      received += 'n'
+
+    }
+
+    msg += ` It must be ${range}. Received ${received}`
+
+    return msg
+
+  }, RangeError)
+
+
+
+function addNumericalSeparator (val) {
+
+  let res = ''
+
+  let i = val.length
+
+  const start = val[0] === '-' ? 1 : 0
+
+  for (; i >= start + 4; i -= 3) {
+
+    res = `_${val.slice(i - 3, i)}${res}`
+
+  }
+
+  return `${val.slice(0, i)}${res}`
+
+}
+
+
+
+// CHECK FUNCTIONS
+
+// ===============
+
+
+
+function checkBounds (buf, offset, byteLength) {
+
+  validateNumber(offset, 'offset')
+
+  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
+
+    boundsError(offset, buf.length - (byteLength + 1))
+
+  }
+
+}
+
+
+
+function checkIntBI (value, min, max, buf, offset, byteLength) {
+
+  if (value > max || value < min) {
+
+    const n = typeof min === 'bigint' ? 'n' : ''
+
+    let range
+
+    if (byteLength > 3) {
+
+      if (min === 0 || min === BigInt(0)) {
+
+        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
+
+      } else {
+
+        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
+
+                `${(byteLength + 1) * 8 - 1}${n}`
+
+      }
+
+    } else {
+
+      range = `>= ${min}${n} and <= ${max}${n}`
+
+    }
+
+    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
+
+  }
+
+  checkBounds(buf, offset, byteLength)
+
+}
+
+
+
+function validateNumber (value, name) {
+
+  if (typeof value !== 'number') {
+
+    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
+
+  }
+
+}
+
+
+
+function boundsError (value, length, type) {
+
+  if (Math.floor(value) !== value) {
+
+    validateNumber(value, type)
+
+    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
+
+  }
+
+
+
+  if (length < 0) {
+
+    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
+
+  }
+
+
+
+  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
+
+                                    `>= ${type ? 1 : 0} and <= ${length}`,
+
+                                    value)
+
+}
+
+
+
+// HELPER FUNCTIONS
+
+// ================
+
+
+
+const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g
+
+
+
+function base64clean (str) {
+
+  // Node takes equal signs as end of the Base64 encoding
+
+  str = str.split('=')[0]
+
+  // Node strips out invalid characters like \n and \t from the string, base64-js does not
+
+  str = str.trim().replace(INVALID_BASE64_RE, '')
+
+  // Node converts strings with length < 2 to ''
+
+  if (str.length < 2) return ''
+
+  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
+
+  while (str.length % 4 !== 0) {
+
+    str = str + '='
+
+  }
+
+  return str
+
+}
+
+
+
+function utf8ToBytes (string, units) {
+
+  units = units || Infinity
+
+  let codePoint
+
+  const length = string.length
+
+  let leadSurrogate = null
+
+  const bytes = []
+
+
+
+  for (let i = 0; i < length; ++i) {
+
+    codePoint = string.charCodeAt(i)
+
+
+
+    // is surrogate component
+
+    if (codePoint > 0xD7FF && codePoint < 0xE000) {
+
+      // last char was a lead
+
+      if (!leadSurrogate) {
+
+        // no lead yet
+
+        if (codePoint > 0xDBFF) {
+
+          // unexpected trail
+
+          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
+
+          continue
+
+        } else if (i + 1 === length) {
+
+          // unpaired lead
+
+          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
+
+          continue
+
+        }
+
+
+
+        // valid lead
+
+        leadSurrogate = codePoint
+
+
+
+        continue
+
+      }
+
+
+
+      // 2 leads in a row
+
+      if (codePoint < 0xDC00) {
+
+        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
+
+        leadSurrogate = codePoint
+
+        continue
+
+      }
+
+
+
+      // valid surrogate pair
+
+      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
+
+    } else if (leadSurrogate) {
+
+      // valid bmp char, but last char was a lead
+
+      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
+
+    }
+
+
+
+    leadSurrogate = null
+
+
+
+    // encode utf8
+
+    if (codePoint < 0x80) {
+
+      if ((units -= 1) < 0) break
+
+      bytes.push(codePoint)
+
+    } else if (codePoint < 0x800) {
+
+      if ((units -= 2) < 0) break
+
+      bytes.push(
+
+        codePoint >> 0x6 | 0xC0,
+
+        codePoint & 0x3F | 0x80
+
+      )
+
+    } else if (codePoint < 0x10000) {
+
+      if ((units -= 3) < 0) break
+
+      bytes.push(
+
+        codePoint >> 0xC | 0xE0,
+
+        codePoint >> 0x6 & 0x3F | 0x80,
+
+        codePoint & 0x3F | 0x80
+
+      )
+
+    } else if (codePoint < 0x110000) {
+
+      if ((units -= 4) < 0) break
+
+      bytes.push(
+
+        codePoint >> 0x12 | 0xF0,
+
+        codePoint >> 0xC & 0x3F | 0x80,
+
+        codePoint >> 0x6 & 0x3F | 0x80,
+
+        codePoint & 0x3F | 0x80
+
+      )
+
+    } else {
+
+      throw new Error('Invalid code point')
+
+    }
+
+  }
+
+
+
+  return bytes
+
+}
+
+
+
+function asciiToBytes (str) {
+
+  const byteArray = []
+
+  for (let i = 0; i < str.length; ++i) {
+
+    // Node's code seems to be doing this and not & 0x7F..
+
+    byteArray.push(str.charCodeAt(i) & 0xFF)
+
+  }
+
+  return byteArray
+
+}
+
+
+
+function utf16leToBytes (str, units) {
+
+  let c, hi, lo
+
+  const byteArray = []
+
+  for (let i = 0; i < str.length; ++i) {
+
+    if ((units -= 2) < 0) break
+
+
+
+    c = str.charCodeAt(i)
+
+    hi = c >> 8
+
+    lo = c % 256
+
+    byteArray.push(lo)
+
+    byteArray.push(hi)
+
+  }
+
+
+
+  return byteArray
+
+}
+
+
+
+function base64ToBytes (str) {
+
+  return base64.toByteArray(base64clean(str))
+
+}
+
+
+
+function blitBuffer (src, dst, offset, length) {
+
+  let i
+
+  for (i = 0; i < length; ++i) {
+
+    if ((i + offset >= dst.length) || (i >= src.length)) break
+
+    dst[i + offset] = src[i]
+
+  }
+
+  return i
+
+}
+
+
+
+// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
+
+// the `instanceof` check but they should be treated as of that type.
+
+// See: https://github.com/feross/buffer/issues/166
+
+function isInstance (obj, type) {
+
+  return obj instanceof type ||
+
+    (obj != null && obj.constructor != null && obj.constructor.name != null &&
+
+      obj.constructor.name === type.name)
+
+}
+
+function numberIsNaN (obj) {
+
+  // For IE11 support
+
+  return obj !== obj // eslint-disable-line no-self-compare
+
+}
+
+
+
+// Create lookup table for `toString('hex')`
+
+// See: https://github.com/feross/buffer/issues/219
+
+const hexSliceLookupTable = (function () {
+
+  const alphabet = '0123456789abcdef'
+
+  const table = new Array(256)
+
+  for (let i = 0; i < 16; ++i) {
+
+    const i16 = i * 16
+
+    for (let j = 0; j < 16; ++j) {
+
+      table[i16 + j] = alphabet[i] + alphabet[j]
+
+    }
+
+  }
+
+  return table
+
+})()
+
+
+
+// Return not function with Error if BigInt not supported
+
+function defineBigIntMethod (fn) {
+
+  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
+
+}
+
+
+
+function BufferBigIntNotDefined () {
+
+  throw new Error('BigInt not supported')
+
+}
diff --git a/node_modules/edgedb/dist/codecs/bytes.js b/node_modules/edgedb/dist/codecs/bytes.js
index 0e4fa01..432b9e9 100644
--- a/node_modules/edgedb/dist/codecs/bytes.js
+++ b/node_modules/edgedb/dist/codecs/bytes.js
@@ -1,34 +1,67 @@
 "use strict";
+const { Buffer } = require("../bufferPolyfill.js")
 /*!
+
  * This source file is part of the EdgeDB open source project.
+
  *
+
  * Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
+
  *
+
  * Licensed under the Apache License, Version 2.0 (the "License");
+
  * you may not use this file except in compliance with the License.
+
  * You may obtain a copy of the License at
+
  *
+
  *     http://www.apache.org/licenses/LICENSE-2.0
+
  *
+
  * Unless required by applicable law or agreed to in writing, software
+
  * distributed under the License is distributed on an "AS IS" BASIS,
+
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+
  * See the License for the specific language governing permissions and
+
  * limitations under the License.
+
  */
+
 Object.defineProperty(exports, "__esModule", { value: true });
+
 exports.BytesCodec = void 0;
+
 const ifaces_1 = require("./ifaces");
+
 class BytesCodec extends ifaces_1.ScalarCodec {
+
     encode(buf, object) {
+
         if (!(object instanceof Buffer)) {
+
             throw new Error(`a Buffer was expected, got "${object}"`);
+
         }
+
         buf.writeInt32(object.length);
+
         buf.writeBuffer(object);
+
     }
+
     decode(buf) {
+
         return buf.consumeAsBuffer();
+
     }
+
 }
+
 exports.BytesCodec = BytesCodec;
diff --git a/node_modules/edgedb/dist/codecs/ifaces.js b/node_modules/edgedb/dist/codecs/ifaces.js
index 229e919..4596db0 100644
--- a/node_modules/edgedb/dist/codecs/ifaces.js
+++ b/node_modules/edgedb/dist/codecs/ifaces.js
@@ -1,84 +1,167 @@
 "use strict";
+const { Buffer } = require("../bufferPolyfill.js")
 /*!
+
  * This source file is part of the EdgeDB open source project.
+
  *
+
  * Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
+
  *
+
  * Licensed under the Apache License, Version 2.0 (the "License");
+
  * you may not use this file except in compliance with the License.
+
  * You may obtain a copy of the License at
+
  *
+
  *     http://www.apache.org/licenses/LICENSE-2.0
+
  *
+
  * Unless required by applicable law or agreed to in writing, software
+
  * distributed under the License is distributed on an "AS IS" BASIS,
+
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+
  * See the License for the specific language governing permissions and
+
  * limitations under the License.
+
  */
+
 Object.defineProperty(exports, "__esModule", { value: true });
+
 exports.ScalarCodec = exports.Codec = void 0;
+
 const consts_1 = require("./consts");
+
 class Codec {
+
     constructor(tid) {
+
         Object.defineProperty(this, "tid", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "tidBuffer", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         this.tid = tid;
+
         this.tidBuffer = Buffer.from(tid, "hex");
+
     }
+
     getKnownTypeName() {
+
         return "anytype";
+
     }
+
 }
+
 exports.Codec = Codec;
+
 class ScalarCodec extends Codec {
+
     constructor(tid, derivedFromTid = null) {
+
         super(tid);
+
         Object.defineProperty(this, "derivedFromTid", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: null
+
         });
+
         Object.defineProperty(this, "typeName", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: null
+
         });
+
         this.derivedFromTid = derivedFromTid;
+
     }
+
     setTypeName(typeName) {
+
         this.typeName = typeName;
+
     }
+
     derive(tid) {
+
         const self = this.constructor;
+
         return new self(tid, this.tid);
+
     }
+
     getSubcodecs() {
+
         return [];
+
     }
+
     getKind() {
+
         return "scalar";
+
     }
+
     getKnownTypeName() {
+
         if (this.typeName) {
+
             return this.typeName;
+
         }
+
         if (this.derivedFromTid) {
+
             return consts_1.KNOWN_TYPES.get(this.derivedFromTid);
+
         }
+
         return consts_1.KNOWN_TYPES.get(this.tid) || "anytype";
+
     }
+
 }
+
 exports.ScalarCodec = ScalarCodec;
diff --git a/node_modules/edgedb/dist/codecs/json.js b/node_modules/edgedb/dist/codecs/json.js
index 977fbde..4f732d8 100644
--- a/node_modules/edgedb/dist/codecs/json.js
+++ b/node_modules/edgedb/dist/codecs/json.js
@@ -1,41 +1,81 @@
 "use strict";
+const { Buffer } = require("../bufferPolyfill.js")
 /*!
+
  * This source file is part of the EdgeDB open source project.
+
  *
+
  * Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
+
  *
+
  * Licensed under the Apache License, Version 2.0 (the "License");
+
  * you may not use this file except in compliance with the License.
+
  * You may obtain a copy of the License at
+
  *
+
  *     http://www.apache.org/licenses/LICENSE-2.0
+
  *
+
  * Unless required by applicable law or agreed to in writing, software
+
  * distributed under the License is distributed on an "AS IS" BASIS,
+
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+
  * See the License for the specific language governing permissions and
+
  * limitations under the License.
+
  */
+
 Object.defineProperty(exports, "__esModule", { value: true });
+
 exports.JSONCodec = void 0;
+
 const ifaces_1 = require("./ifaces");
+
 class JSONCodec extends ifaces_1.ScalarCodec {
+
     encode(buf, object) {
+
         if (typeof object !== "string") {
+
             throw new Error(`a string was expected, got "${object}"`);
+
         }
+
         const val = object;
+
         const strbuf = Buffer.from(val, "utf8");
+
         buf.writeInt32(strbuf.length + 1);
+
         buf.writeChar(1);
+
         buf.writeBuffer(strbuf);
+
     }
+
     decode(buf) {
+
         const format = buf.readUInt8();
+
         if (format !== 1) {
+
             throw new Error(`unexpected JSON format ${format}`);
+
         }
+
         return buf.consumeAsString();
+
     }
+
 }
+
 exports.JSONCodec = JSONCodec;
diff --git a/node_modules/edgedb/dist/codecs/text.js b/node_modules/edgedb/dist/codecs/text.js
index 69c24e1..a619016 100644
--- a/node_modules/edgedb/dist/codecs/text.js
+++ b/node_modules/edgedb/dist/codecs/text.js
@@ -1,36 +1,71 @@
 "use strict";
+const { Buffer } = require("../bufferPolyfill.js")
 /*!
+
  * This source file is part of the EdgeDB open source project.
+
  *
+
  * Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
+
  *
+
  * Licensed under the Apache License, Version 2.0 (the "License");
+
  * you may not use this file except in compliance with the License.
+
  * You may obtain a copy of the License at
+
  *
+
  *     http://www.apache.org/licenses/LICENSE-2.0
+
  *
+
  * Unless required by applicable law or agreed to in writing, software
+
  * distributed under the License is distributed on an "AS IS" BASIS,
+
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+
  * See the License for the specific language governing permissions and
+
  * limitations under the License.
+
  */
+
 Object.defineProperty(exports, "__esModule", { value: true });
+
 exports.StrCodec = void 0;
+
 const ifaces_1 = require("./ifaces");
+
 class StrCodec extends ifaces_1.ScalarCodec {
+
     encode(buf, object) {
+
         if (typeof object !== "string") {
+
             throw new Error(`a string was expected, got "${object}"`);
+
         }
+
         const val = object;
+
         const strbuf = Buffer.from(val, "utf8");
+
         buf.writeInt32(strbuf.length);
+
         buf.writeBuffer(strbuf);
+
     }
+
     decode(buf) {
+
         return buf.consumeAsString();
+
     }
+
 }
+
 exports.StrCodec = StrCodec;
diff --git a/node_modules/edgedb/dist/codecs/uuid.js b/node_modules/edgedb/dist/codecs/uuid.js
index e65ddd6..892b6ac 100644
--- a/node_modules/edgedb/dist/codecs/uuid.js
+++ b/node_modules/edgedb/dist/codecs/uuid.js
@@ -1,52 +1,103 @@
 "use strict";
+const { Buffer } = require("../bufferPolyfill.js")
 /*!
+
  * This source file is part of the EdgeDB open source project.
+
  *
+
  * Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
+
  *
+
  * Licensed under the Apache License, Version 2.0 (the "License");
+
  * you may not use this file except in compliance with the License.
+
  * You may obtain a copy of the License at
+
  *
+
  *     http://www.apache.org/licenses/LICENSE-2.0
+
  *
+
  * Unless required by applicable law or agreed to in writing, software
+
  * distributed under the License is distributed on an "AS IS" BASIS,
+
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+
  * See the License for the specific language governing permissions and
+
  * limitations under the License.
+
  */
+
 Object.defineProperty(exports, "__esModule", { value: true });
+
 exports.UUIDCodec = void 0;
+
 const ifaces_1 = require("./ifaces");
+
 function UUIDBufferFromString(uuid) {
+
     let uuidClean = uuid;
+
     if (uuidClean.length !== 32) {
+
         uuidClean = uuidClean.replace(/\-/g, "");
+
         if (uuidClean.length !== 32) {
+
             throw new TypeError(`invalid UUID "${uuid}"`);
+
         }
+
     }
+
     const buf = Buffer.from(uuidClean, "hex");
+
     if (buf.length !== 16) {
+
         throw new TypeError(`invalid UUID "${uuid}"`);
+
     }
+
     return buf;
+
 }
+
 class UUIDCodec extends ifaces_1.ScalarCodec {
+
     encode(buf, object) {
+
         if (typeof object === "string") {
+
             const val = object;
+
             const ubuf = UUIDBufferFromString(val);
+
             buf.writeInt32(16);
+
             buf.writeBuffer(ubuf);
+
         }
+
         else {
+
             throw new Error(`cannot encode UUID "${object}": invalid type`);
+
         }
+
     }
+
     decode(buf) {
+
         return buf.readBuffer(16).toString("hex");
+
     }
+
 }
+
 exports.UUIDCodec = UUIDCodec;
diff --git a/node_modules/edgedb/dist/fetchConn.js b/node_modules/edgedb/dist/fetchConn.js
index b32f23c..8c04d6d 100644
--- a/node_modules/edgedb/dist/fetchConn.js
+++ b/node_modules/edgedb/dist/fetchConn.js
@@ -1,138 +1,275 @@
 "use strict";
+const { Buffer } = require("../bufferPolyfill.js")
 /*!
+
  * This source file is part of the EdgeDB open source project.
+
  *
+
  * Copyright 2022-present MagicStack Inc. and the EdgeDB authors.
+
  *
+
  * Licensed under the Apache License, Version 2.0 (the "License");
+
  * you may not use this file except in compliance with the License.
+
  * You may obtain a copy of the License at
+
  *
+
  *     http://www.apache.org/licenses/LICENSE-2.0
+
  *
+
  * Unless required by applicable law or agreed to in writing, software
+
  * distributed under the License is distributed on an "AS IS" BASIS,
+
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+
  * See the License for the specific language governing permissions and
+
  * limitations under the License.
+
  */
+
 var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+
     if (k2 === undefined) k2 = k;
+
     Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
+
 }) : (function(o, m, k, k2) {
+
     if (k2 === undefined) k2 = k;
+
     o[k2] = m[k];
+
 }));
+
 var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+
     Object.defineProperty(o, "default", { enumerable: true, value: v });
+
 }) : function(o, v) {
+
     o["default"] = v;
+
 });
+
 var __importStar = (this && this.__importStar) || function (mod) {
+
     if (mod && mod.__esModule) return mod;
+
     var result = {};
+
     if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+
     __setModuleDefault(result, mod);
+
     return result;
+
 };
+
 var __importDefault = (this && this.__importDefault) || function (mod) {
+
     return (mod && mod.__esModule) ? mod : { "default": mod };
+
 };
+
 Object.defineProperty(exports, "__esModule", { value: true });
+
 exports.AdminFetchConnection = void 0;
+
 const baseConn_1 = require("./baseConn");
+
 const event_1 = __importDefault(require("./primitives/event"));
+
 const chars = __importStar(require("./primitives/chars"));
+
 if (typeof fetch === "undefined") {
+
     globalThis.fetch = require("node-fetch");
+
 }
+
 const PROTO_MIME = (`application/x.edgedb.v_${baseConn_1.PROTO_VER[0]}_${baseConn_1.PROTO_VER[1]}.binary'`);
+
 class BaseFetchConnection extends baseConn_1.BaseRawConnection {
+
     constructor(config, registry) {
+
         super(registry);
+
         Object.defineProperty(this, "config", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "addr", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         this.config = config;
+
         this.addr = this._buildAddr();
+
     }
+
     _buildAddr() {
+
         this.throwNotImplemented('_buildAddr');
+
     }
+
     async _waitForMessage() {
+
         if (this.buffer.takeMessage()) {
+
             return;
+
         }
+
         if (this.messageWaiter == null || this.messageWaiter.done) {
+
             throw new Error(`message waiter was not initialized before waiting for response`);
+
         }
+
         await this.messageWaiter.wait();
+
     }
+
     async __sendData(data) {
+
         if (this.buffer.takeMessage()) {
+
             const mtype = this.buffer.getMessageType();
+
             throw new Error(`sending request before reading all data of the previous one: ` +
+
                 `${chars.chr(mtype)}`);
+
         }
+
         if (this.messageWaiter != null && !this.messageWaiter.done) {
+
             throw new Error(`sending request before waiting for completion of the previous one`);
+
         }
+
         this.messageWaiter = new event_1.default();
+
         try {
+
             const resp = await fetch(this.addr, {
+
                 method: "post",
+
                 body: data,
+
                 headers: { "Content-Type": PROTO_MIME },
+
             });
+
             if (!resp.ok) {
+
                 throw new Error(`fetch failed with status code ${resp.status}: ${resp.statusText}`);
+
             }
+
             const respData = await resp.arrayBuffer();
+
             const buf = Buffer.from(respData);
+
             let pause = false;
+
             try {
+
                 pause = this.buffer.feed(buf);
+
             }
+
             catch (e) {
+
                 this.messageWaiter.setError(e);
+
             }
+
             if (pause) {
+
                 throw new Error('too much data received');
+
             }
+
             if (!this.buffer.takeMessage()) {
+
                 throw new Error('no binary protocol messages in the response');
+
             }
+
             this.messageWaiter.set();
+
         }
+
         catch (e) {
+
             this.messageWaiter.setError(e);
+
         }
+
     }
+
     _sendData(data) {
+
         this.__sendData(data);
+
     }
+
     static create(config, registry) {
+
         const conn = new this(config, registry);
+
         conn.connected = true;
+
         conn.alwaysUseOptimisticFlow = true;
+
         conn.exposeErrorAttributes = true;
+
         return conn;
+
     }
+
 }
+
 class AdminFetchConnection extends BaseFetchConnection {
+
     _buildAddr() {
+
         const config = this.config;
+
         return `${typeof config.address === "string" ?
+
             config.address : `http://${config.address[0]}:${config.address[1]}`}/db/${config.database}/admin_binary_http`;
+
     }
+
 }
+
 exports.AdminFetchConnection = AdminFetchConnection;
diff --git a/node_modules/edgedb/dist/primitives/buffer.js b/node_modules/edgedb/dist/primitives/buffer.js
index 0e5b7ec..3ee3709 100644
--- a/node_modules/edgedb/dist/primitives/buffer.js
+++ b/node_modules/edgedb/dist/primitives/buffer.js
@@ -1,910 +1,1819 @@
 "use strict";
+const { Buffer } = require("../bufferPolyfill.js")
 /*!
+
  * This source file is part of the EdgeDB open source project.
+
  *
+
  * Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
+
  *
+
  * Licensed under the Apache License, Version 2.0 (the "License");
+
  * you may not use this file except in compliance with the License.
+
  * You may obtain a copy of the License at
+
  *
+
  *     http://www.apache.org/licenses/LICENSE-2.0
+
  *
+
  * Unless required by applicable law or agreed to in writing, software
+
  * distributed under the License is distributed on an "AS IS" BASIS,
+
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+
  * See the License for the specific language governing permissions and
+
  * limitations under the License.
+
  */
+
 var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+
     if (k2 === undefined) k2 = k;
+
     Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
+
 }) : (function(o, m, k, k2) {
+
     if (k2 === undefined) k2 = k;
+
     o[k2] = m[k];
+
 }));
+
 var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+
     Object.defineProperty(o, "default", { enumerable: true, value: v });
+
 }) : function(o, v) {
+
     o["default"] = v;
+
 });
+
 var __importStar = (this && this.__importStar) || function (mod) {
+
     if (mod && mod.__esModule) return mod;
+
     var result = {};
+
     if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+
     __setModuleDefault(result, mod);
+
     return result;
+
 };
+
 Object.defineProperty(exports, "__esModule", { value: true });
+
 exports.ReadBuffer = exports.ReadMessageBuffer = exports.WriteMessageBuffer = exports.WriteBuffer = exports.BufferError = void 0;
+
 const chars = __importStar(require("./chars"));
+
 const ring_1 = require("./ring");
+
 const bi = __importStar(require("./bigint"));
+
 const compat = __importStar(require("../compat"));
+
 const ifaces_1 = require("../ifaces");
+
 const BUFFER_INC_SIZE = 4096;
+
 const BUFFER_RING_CAPACITY = 2048;
+
 const EMPTY_BUFFER = Buffer.allocUnsafe(0);
+
 const isNode12 = !!Buffer["readBigInt64BE"];
+
 class BufferError extends Error {
+
 }
+
 exports.BufferError = BufferError;
+
 class WriteBuffer {
+
     constructor() {
+
         Object.defineProperty(this, "buffer", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "size", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "pos", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         this.size = BUFFER_INC_SIZE;
+
         this.pos = 0;
+
         this.buffer = Buffer.allocUnsafe(this.size);
+
     }
+
     get position() {
+
         return this.pos;
+
     }
+
     reset() {
+
         this.pos = 0;
+
     }
+
     ensureAlloced(extraLength) {
+
         const newSize = this.pos + extraLength;
+
         if (newSize > this.size) {
+
             this.__realloc(newSize);
+
         }
+
     }
+
     __realloc(newSize) {
+
         newSize += BUFFER_INC_SIZE;
+
         const newBuffer = Buffer.allocUnsafe(newSize);
+
         this.buffer.copy(newBuffer, 0, 0, this.pos);
+
         this.buffer = newBuffer;
+
         this.size = newSize;
+
     }
+
     writeChar(ch) {
+
         this.ensureAlloced(1);
+
         this.buffer.writeUInt8(ch, this.pos);
+
         this.pos++;
+
         return this;
+
     }
+
     writeString(s) {
+
         return this.writeBytes(Buffer.from(s, "utf-8"));
+
     }
+
     writeBytes(buf) {
+
         this.ensureAlloced(buf.length + 4);
+
         this.buffer.writeInt32BE(buf.length, this.pos);
+
         this.pos += 4;
+
         buf.copy(this.buffer, this.pos, 0, buf.length);
+
         this.pos += buf.length;
+
         return this;
+
     }
+
     writeInt16(i) {
+
         this.ensureAlloced(2);
+
         this.buffer.writeInt16BE(i, this.pos);
+
         this.pos += 2;
+
         return this;
+
     }
+
     writeInt32(i) {
+
         this.ensureAlloced(4);
+
         this.buffer.writeInt32BE(i, this.pos);
+
         this.pos += 4;
+
         return this;
+
     }
+
     writeFloat32(i) {
+
         this.ensureAlloced(4);
+
         this.buffer.writeFloatBE(i, this.pos);
+
         this.pos += 4;
+
         return this;
+
     }
+
     writeFloat64(i) {
+
         this.ensureAlloced(8);
+
         this.buffer.writeDoubleBE(i, this.pos);
+
         this.pos += 8;
+
         return this;
+
     }
+
     writeUInt16(i) {
+
         this.ensureAlloced(2);
+
         this.buffer.writeUInt16BE(i, this.pos);
+
         this.pos += 2;
+
         return this;
+
     }
+
     writeUInt32(i) {
+
         this.ensureAlloced(4);
+
         this.buffer.writeUInt32BE(i, this.pos);
+
         this.pos += 4;
+
         return this;
+
     }
+
     writeInt64(i) {
+
         const hi = Math.floor(i / 0x100000000);
+
         const lo = i - hi * 0x100000000;
+
         this.writeInt32(hi);
+
         this.writeUInt32(lo);
+
         return this;
+
     }
+
     writeBigInt64(i) {
+
         let ii = i;
+
         if (bi.lt(ii, bi.make(0))) {
+
             ii = bi.add(bi.make("18446744073709551616"), i);
+
         }
+
         const hi = bi.rshift(ii, bi.make(32));
+
         const lo = bi.bitand(ii, bi.make(0xffffffff));
+
         this.writeUInt32(Number(hi));
+
         this.writeUInt32(Number(lo));
+
         return this;
+
     }
+
     writeBuffer(buf) {
+
         const len = buf.length;
+
         this.ensureAlloced(len);
+
         buf.copy(this.buffer, this.pos, 0, len);
+
         this.pos += len;
+
         return this;
+
     }
+
     unwrap() {
+
         return this.buffer.slice(0, this.pos);
+
     }
+
 }
+
 exports.WriteBuffer = WriteBuffer;
+
 class WriteMessageBuffer {
+
     constructor() {
+
         Object.defineProperty(this, "buffer", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "messagePos", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         this.messagePos = -1;
+
         this.buffer = new WriteBuffer();
+
     }
+
     reset() {
+
         this.messagePos = -1;
+
         this.buffer.reset();
+
         return this;
+
     }
+
     beginMessage(mtype) {
+
         if (this.messagePos >= 0) {
+
             throw new BufferError("cannot begin a new message: the previous message is not finished");
+
         }
+
         this.messagePos = this.buffer.position;
+
         this.buffer.writeChar(mtype);
+
         this.buffer.writeInt32(0);
+
         return this;
+
     }
+
     endMessage() {
+
         if (this.messagePos < 0) {
+
             throw new BufferError("cannot end the message: no current message");
+
         }
+
         this.buffer.buffer.writeInt32BE(this.buffer.position - this.messagePos - 1, this.messagePos + 1);
+
         this.messagePos = -1;
+
         return this;
+
     }
+
     writeHeaders(headers) {
+
         if (this.messagePos < 0) {
+
             throw new BufferError("cannot writeHeaders: no current message");
+
         }
+
         if (!headers) {
+
             this.buffer.writeUInt16(0);
+
             return this;
+
         }
+
         const entries = Object.entries(headers).filter(([_, value]) => value !== undefined);
+
         this.buffer.writeUInt16(entries.length);
+
         for (const [code, value] of entries) {
+
             this.buffer.writeUInt16(ifaces_1.HeaderCodes[code]);
+
             if (Buffer.isBuffer(value)) {
+
                 this.buffer.writeUInt32(value.byteLength);
+
                 this.buffer.writeBuffer(value);
+
             }
+
             else if (typeof value === "string") {
+
                 this.buffer.writeString(value);
+
             }
+
             else {
+
                 throw new BufferError("cannot write header: value is not a Buffer or string");
+
             }
+
         }
+
         return this;
+
     }
+
     writeChar(ch) {
+
         if (this.messagePos < 0) {
+
             throw new BufferError("cannot writeChar: no current message");
+
         }
+
         this.buffer.writeChar(ch);
+
         return this;
+
     }
+
     writeString(s) {
+
         if (this.messagePos < 0) {
+
             throw new BufferError("cannot writeString: no current message");
+
         }
+
         this.buffer.writeString(s);
+
         return this;
+
     }
+
     writeBytes(val) {
+
         if (this.messagePos < 0) {
+
             throw new BufferError("cannot writeBytes: no current message");
+
         }
+
         this.buffer.writeBytes(val);
+
         return this;
+
     }
+
     writeInt16(i) {
+
         if (this.messagePos < 0) {
+
             throw new BufferError("cannot writeInt16: no current message");
+
         }
+
         this.buffer.writeInt16(i);
+
         return this;
+
     }
+
     writeInt32(i) {
+
         if (this.messagePos < 0) {
+
             throw new BufferError("cannot writeInt32: no current message");
+
         }
+
         this.buffer.writeInt32(i);
+
         return this;
+
     }
+
     writeUInt16(i) {
+
         if (this.messagePos < 0) {
+
             throw new BufferError("cannot writeInt16: no current message");
+
         }
+
         this.buffer.writeUInt16(i);
+
         return this;
+
     }
+
     writeUInt32(i) {
+
         if (this.messagePos < 0) {
+
             throw new BufferError("cannot writeInt32: no current message");
+
         }
+
         this.buffer.writeUInt32(i);
+
         return this;
+
     }
+
     writeBuffer(buf) {
+
         if (this.messagePos < 0) {
+
             throw new BufferError("cannot writeBuffer: no current message");
+
         }
+
         this.buffer.writeBuffer(buf);
+
         return this;
+
     }
+
     writeSync() {
+
         if (this.messagePos >= 0) {
+
             throw new BufferError("cannot writeSync: the previous message is not finished");
+
         }
+
         this.buffer.writeBuffer(SYNC_MESSAGE);
+
         return this;
+
     }
+
     writeFlush() {
+
         if (this.messagePos >= 0) {
+
             throw new BufferError("cannot writeFlush: the previous message is not finished");
+
         }
+
         this.buffer.writeBuffer(FLUSH_MESSAGE);
+
         return this;
+
     }
+
     unwrap() {
+
         if (this.messagePos >= 0) {
+
             throw new BufferError("cannot unwrap: an unfinished message is in the buffer");
+
         }
+
         return this.buffer.unwrap();
+
     }
+
 }
+
 exports.WriteMessageBuffer = WriteMessageBuffer;
+
 const SYNC_MESSAGE = new WriteMessageBuffer()
+
     .beginMessage(chars.$S)
+
     .endMessage()
+
     .unwrap();
+
 const FLUSH_MESSAGE = new WriteMessageBuffer()
+
     .beginMessage(chars.$H)
+
     .endMessage()
+
     .unwrap();
+
 class ReadMessageBuffer {
+
     constructor() {
+
         Object.defineProperty(this, "bufs", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "len", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "buf0", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "pos0", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "len0", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "curMessageType", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "curMessageLen", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "curMessageLenUnread", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "curMessageReady", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         this.bufs = new ring_1.RingBuffer({ capacity: BUFFER_RING_CAPACITY });
+
         this.buf0 = null;
+
         this.pos0 = 0;
+
         this.len0 = 0;
+
         this.len = 0;
+
         this.curMessageType = 0;
+
         this.curMessageLen = 0;
+
         this.curMessageLenUnread = 0;
+
         this.curMessageReady = false;
+
     }
+
     get length() {
+
         return this.len;
+
     }
+
     feed(buf) {
+
         if (this.buf0 == null ||
+
             (this.pos0 === this.len0 && this.bufs.length === 0)) {
+
             this.buf0 = buf;
+
             this.len0 = buf.length;
+
             this.pos0 = 0;
+
             this.len = this.len0;
+
             return false;
+
         }
+
         else {
+
             return this.feedEnqueue(buf);
+
         }
+
     }
+
     feedEnqueue(buf) {
+
         this.bufs.enq(buf);
+
         this.len += buf.length;
+
         const isFull = this.bufs.full;
+
         if (isFull && this.curMessageType !== 0) {
+
             throw new Error("query result is too big: buffer overflow");
+
         }
+
         return isFull;
+
     }
+
     ensureFirstBuf() {
+
         if (this.pos0 === this.len0) {
+
             this.__nextBuf();
+
         }
+
         const buf0 = this.buf0;
+
         if (buf0 == null || buf0.length < 1) {
+
             throw new BufferError("empty buffer");
+
         }
+
         return buf0;
+
     }
+
     checkOverread(size) {
+
         if (this.curMessageLenUnread < size || size > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
     }
+
     __nextBuf() {
+
         const nextBuf = this.bufs.deq();
+
         if (nextBuf == null) {
+
             throw new BufferError("buffer overread");
+
         }
+
         this.buf0 = nextBuf;
+
         this.pos0 = 0;
+
         this.len0 = nextBuf.length;
+
     }
+
     discardBuffer(size) {
+
         this.ensureFirstBuf();
+
         while (true) {
+
             if (this.pos0 + size > this.len0) {
+
                 const nread = this.len0 - this.pos0;
+
                 this.pos0 = this.len0;
+
                 this.len -= nread;
+
                 size -= nread;
+
                 this.ensureFirstBuf();
+
             }
+
             else {
+
                 this.pos0 += size;
+
                 this.len -= size;
+
                 break;
+
             }
+
         }
+
     }
+
     _finishMessage() {
+
         this.curMessageLen = 0;
+
         this.curMessageLenUnread = 0;
+
         this.curMessageReady = false;
+
         this.curMessageType = 0;
+
     }
+
     __readBufferCopy(buf0, size) {
+
         const ret = Buffer.allocUnsafe(size);
+
         let retPos = 0;
+
         while (true) {
+
             if (this.pos0 + size > this.len0) {
+
                 const nread = this.len0 - this.pos0;
+
                 buf0.copy(ret, retPos, this.pos0, this.len0);
+
                 retPos += nread;
+
                 this.pos0 = this.len0;
+
                 this.len -= nread;
+
                 size -= nread;
+
                 buf0 = this.ensureFirstBuf();
+
             }
+
             else {
+
                 buf0.copy(ret, retPos, this.pos0, this.pos0 + size);
+
                 this.pos0 += size;
+
                 this.len -= size;
+
                 break;
+
             }
+
         }
+
         return ret;
+
     }
+
     _readBuffer(size) {
+
         const buf0 = this.ensureFirstBuf();
+
         if (size === 0) {
+
             return EMPTY_BUFFER;
+
         }
+
         if (this.pos0 + size <= this.len0) {
+
             const ret = buf0.slice(this.pos0, this.pos0 + size);
+
             this.pos0 += size;
+
             this.len -= size;
+
             return ret;
+
         }
+
         return this.__readBufferCopy(buf0, size);
+
     }
+
     readBuffer(size) {
+
         this.checkOverread(size);
+
         const buf = this._readBuffer(size);
+
         this.curMessageLenUnread -= size;
+
         return buf;
+
     }
+
     readUUID() {
+
         const buf = this.readBuffer(16);
+
         return buf.toString("hex");
+
     }
+
     readChar() {
+
         this.checkOverread(1);
+
         const buf0 = this.ensureFirstBuf();
+
         const ret = buf0.readUInt8(this.pos0);
+
         this.pos0++;
+
         this.curMessageLenUnread--;
+
         this.len--;
+
         return ret;
+
     }
+
     readInt16() {
+
         this.checkOverread(2);
+
         const buf0 = this.ensureFirstBuf();
+
         if (this.pos0 + 2 <= this.len0) {
+
             const ret = buf0.readInt16BE(this.pos0);
+
             this.pos0 += 2;
+
             this.curMessageLenUnread -= 2;
+
             this.len -= 2;
+
             return ret;
+
         }
+
         const buf = this._readBuffer(2);
+
         this.curMessageLenUnread -= 2;
+
         return buf.readInt16BE(0);
+
     }
+
     readInt32() {
+
         this.checkOverread(4);
+
         const buf0 = this.ensureFirstBuf();
+
         if (this.pos0 + 4 <= this.len0) {
+
             const ret = buf0.readInt32BE(this.pos0);
+
             this.pos0 += 4;
+
             this.curMessageLenUnread -= 4;
+
             this.len -= 4;
+
             return ret;
+
         }
+
         const buf = this._readBuffer(4);
+
         this.curMessageLenUnread -= 4;
+
         return buf.readInt32BE(0);
+
     }
+
     readUInt16() {
+
         this.checkOverread(2);
+
         const buf0 = this.ensureFirstBuf();
+
         if (this.pos0 + 2 <= this.len0) {
+
             const ret = buf0.readUInt16BE(this.pos0);
+
             this.pos0 += 2;
+
             this.curMessageLenUnread -= 2;
+
             this.len -= 2;
+
             return ret;
+
         }
+
         const buf = this._readBuffer(2);
+
         this.curMessageLenUnread -= 2;
+
         return buf.readUInt16BE(0);
+
     }
+
     readUInt32() {
+
         this.checkOverread(4);
+
         const buf0 = this.ensureFirstBuf();
+
         if (this.pos0 + 4 <= this.len0) {
+
             const ret = buf0.readUInt32BE(this.pos0);
+
             this.pos0 += 4;
+
             this.curMessageLenUnread -= 4;
+
             this.len -= 4;
+
             return ret;
+
         }
+
         const buf = this._readBuffer(4);
+
         this.curMessageLenUnread -= 4;
+
         return buf.readUInt32BE(0);
+
     }
+
     readString() {
+
         const len = this.readInt32();
+
         const buf = this.readBuffer(len);
+
         return buf.toString("utf-8");
+
     }
+
     readLenPrefixedBuffer() {
+
         const len = this.readInt32();
+
         return this.readBuffer(len);
+
     }
+
     takeMessage() {
+
         if (this.curMessageReady) {
+
             return true;
+
         }
+
         if (this.curMessageType === 0) {
+
             if (this.len < 1) {
+
                 return false;
+
             }
+
             const buf0 = this.ensureFirstBuf();
+
             this.curMessageType = buf0.readUInt8(this.pos0);
+
             this.pos0++;
+
             this.len--;
+
         }
+
         if (this.curMessageLen === 0) {
+
             if (this.len < 4) {
+
                 return false;
+
             }
+
             const buf0 = this.ensureFirstBuf();
+
             if (this.pos0 + 4 <= this.len0) {
+
                 this.curMessageLen = buf0.readInt32BE(this.pos0);
+
                 this.pos0 += 4;
+
                 this.len -= 4;
+
             }
+
             else {
+
                 const buf = this._readBuffer(4);
+
                 this.curMessageLen = buf.readInt32BE(0);
+
             }
+
             this.curMessageLenUnread = this.curMessageLen - 4;
+
         }
+
         if (this.len < this.curMessageLenUnread) {
+
             return false;
+
         }
+
         this.curMessageReady = true;
+
         return true;
+
     }
+
     getMessageType() {
+
         return this.curMessageType;
+
     }
+
     takeMessageType(mtype) {
+
         if (this.curMessageReady) {
+
             return this.curMessageType === mtype;
+
         }
+
         if (this.len >= 1) {
+
             const buf0 = this.ensureFirstBuf();
+
             const unreadMessageType = buf0.readUInt8(this.pos0);
+
             return mtype === unreadMessageType && this.takeMessage();
+
         }
+
         return false;
+
     }
+
     putMessage() {
+
         if (!this.curMessageReady) {
+
             throw new BufferError("cannot put message: no message taken");
+
         }
+
         if (this.curMessageLenUnread !== this.curMessageLen - 4) {
+
             throw new BufferError("cannot put message: message is partially read");
+
         }
+
         this.curMessageReady = false;
+
     }
+
     discardMessage() {
+
         if (!this.curMessageReady) {
+
             throw new BufferError("no message to discard");
+
         }
+
         if (this.curMessageLenUnread > 0) {
+
             this.discardBuffer(this.curMessageLenUnread);
+
         }
+
         this._finishMessage();
+
     }
+
     consumeMessage() {
+
         if (!this.curMessageReady) {
+
             throw new BufferError("no message to consume");
+
         }
+
         let buf;
+
         if (this.curMessageLenUnread > 0) {
+
             buf = this._readBuffer(this.curMessageLenUnread);
+
             this.curMessageLenUnread = 0;
+
         }
+
         else {
+
             buf = EMPTY_BUFFER;
+
         }
+
         this._finishMessage();
+
         return buf;
+
     }
+
     consumeMessageInto(frb) {
+
         if (!this.curMessageReady) {
+
             throw new BufferError("no message to consume");
+
         }
+
         if (this.curMessageLenUnread > 0) {
+
             if (this.pos0 + this.curMessageLenUnread <= this.len0) {
+
                 const len = this.pos0 + this.curMessageLenUnread;
+
                 ReadBuffer.slice(frb, this.buf0, this.pos0, len);
+
                 this.pos0 = len;
+
                 this.len -= this.curMessageLenUnread;
+
             }
+
             else {
+
                 const buf = this._readBuffer(this.curMessageLenUnread);
+
                 ReadBuffer.init(frb, buf);
+
             }
+
             this.curMessageLenUnread = 0;
+
         }
+
         else {
+
             ReadBuffer.init(frb, EMPTY_BUFFER);
+
         }
+
         this._finishMessage();
+
     }
+
     finishMessage() {
+
         if (this.curMessageType === 0 || !this.curMessageReady) {
+
             return;
+
         }
+
         if (this.curMessageLenUnread) {
+
             throw new BufferError(`cannot finishMessage: unread data in message ` +
+
                 `"${chars.chr(this.curMessageType)}"`);
+
         }
+
         this._finishMessage();
+
     }
+
 }
+
 exports.ReadMessageBuffer = ReadMessageBuffer;
+
 class ReadBuffer {
+
     constructor(buf) {
+
         Object.defineProperty(this, "buffer", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "pos", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         Object.defineProperty(this, "len", {
+
             enumerable: true,
+
             configurable: true,
+
             writable: true,
+
             value: void 0
+
         });
+
         this.buffer = buf;
+
         this.len = buf.length;
+
         this.pos = 0;
+
     }
+
     get position() {
+
         return this.pos;
+
     }
+
     get length() {
+
         return this.len - this.pos;
+
     }
+
     finish() {
+
         if (this.len !== this.pos) {
+
             throw new BufferError("unexpected trailing data in buffer");
+
         }
+
     }
+
     discard(size) {
+
         if (this.pos + size > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         this.pos += size;
+
     }
+
     readUInt8() {
+
         if (this.pos + 1 > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         const num = this.buffer.readUInt8(this.pos);
+
         this.pos++;
+
         return num;
+
     }
+
     readUInt16() {
+
         if (this.pos + 2 > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         const num = this.buffer.readUInt16BE(this.pos);
+
         this.pos += 2;
+
         return num;
+
     }
+
     readInt8() {
+
         if (this.pos + 1 > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         const num = this.buffer.readInt8(this.pos);
+
         this.pos++;
+
         return num;
+
     }
+
     readInt16() {
+
         if (this.pos + 2 > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         const num = this.buffer.readInt16BE(this.pos);
+
         this.pos += 2;
+
         return num;
+
     }
+
     readInt32() {
+
         if (this.pos + 4 > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         const num = this.buffer.readInt32BE(this.pos);
+
         this.pos += 4;
+
         return num;
+
     }
+
     readFloat32() {
+
         if (this.pos + 4 > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         const num = this.buffer.readFloatBE(this.pos);
+
         this.pos += 4;
+
         return num;
+
     }
+
     readFloat64() {
+
         if (this.pos + 8 > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         const num = this.buffer.readDoubleBE(this.pos);
+
         this.pos += 8;
+
         return num;
+
     }
+
     readUInt32() {
+
         if (this.pos + 4 > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         const num = this.buffer.readUInt32BE(this.pos);
+
         this.pos += 4;
+
         return num;
+
     }
+
     reportInt64Overflow(hi, lo) {
+
         const bhi = bi.make(hi);
+
         const blo = bi.make(lo >>> 0);
+
         const num = bi.add(bi.mul(bhi, bi.make(0x100000000)), blo);
+
         throw new Error(`integer overflow: cannot unpack <std::int64>'${num.toString()}' ` +
+
             `into JavaScript Number type without losing precision`);
+
     }
+
     readInt64() {
+
         if (this.pos + 8 > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         const hi = this.buffer.readInt32BE(this.pos);
+
         const lo = this.buffer.readInt32BE(this.pos + 4);
+
         this.pos += 8;
+
         if (hi === 0) {
+
             return lo >>> 0;
+
         }
+
         else if (hi >= -0x200000 && hi < 0x200000) {
+
             return hi * 4294967296 + (lo >>> 0);
+
         }
+
         return this.reportInt64Overflow(hi, lo);
+
     }
+
     readBigInt64Fallback() {
+
         if (bi.hasNativeBigInt) {
+
             const hi = this.buffer.readUInt32BE(this.pos);
+
             const lo = this.buffer.readUInt32BE(this.pos + 4);
+
             this.pos += 8;
+
             let res = (BigInt(hi) << BigInt(32)) + BigInt(lo);
+
             if (hi >= 0x80000000) {
+
                 res = BigInt("-18446744073709551616") + res;
+
             }
+
             return res;
+
         }
+
         else {
+
             const buf = this.readBuffer(8);
+
             const snum = compat.decodeInt64ToString(buf);
+
             return bi.make(snum);
+
         }
+
     }
+
     readBigInt64() {
+
         if (this.pos + 8 > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         if (isNode12) {
+
             const ret = this.buffer.readBigInt64BE(this.pos);
+
             this.pos += 8;
+
             return ret;
+
         }
+
         else {
+
             return this.readBigInt64Fallback();
+
         }
+
     }
+
     readBuffer(size) {
+
         if (this.pos + size > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         const buf = this.buffer.slice(this.pos, this.pos + size);
+
         this.pos += size;
+
         return buf;
+
     }
+
     readUUID() {
+
         if (this.pos + 16 > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         const buf = this.buffer.slice(this.pos, this.pos + 16);
+
         this.pos += 16;
+
         return buf.toString("hex");
+
     }
+
     consumeAsString() {
+
         if (this.pos === this.len) {
+
             return "";
+
         }
+
         const res = this.buffer.toString("utf8", this.pos, this.len);
+
         this.pos = this.len;
+
         return res;
+
     }
+
     consumeAsBuffer() {
+
         const res = this.buffer.slice(this.pos, this.len);
+
         this.pos = this.len;
+
         return res;
+
     }
+
     sliceInto(frb, size) {
+
         if (this.pos + size > this.len) {
+
             throw new BufferError("buffer overread");
+
         }
+
         frb.buffer = this.buffer;
+
         frb.pos = this.pos;
+
         frb.len = this.pos + size;
+
         this.pos += size;
+
     }
+
     static init(frb, buffer) {
+
         frb.buffer = buffer;
+
         frb.pos = 0;
+
         frb.len = buffer.length;
+
     }
+
     static slice(frb, buffer, pos, len) {
+
         frb.buffer = buffer;
+
         frb.pos = pos;
+
         frb.len = len;
+
     }
+
     static alloc() {
+
         return new this(EMPTY_BUFFER);
+
     }
+
 }
+
 exports.ReadBuffer = ReadBuffer;
diff --git a/node_modules/edgedb/dist/reflection/cli.js b/node_modules/edgedb/dist/reflection/cli.js
old mode 100755
new mode 100644
diff --git a/node_modules/edgedb/dist/scram.js b/node_modules/edgedb/dist/scram.js
index 35ec869..4eb9fa5 100644
--- a/node_modules/edgedb/dist/scram.js
+++ b/node_modules/edgedb/dist/scram.js
@@ -1,135 +1,103 @@
 "use strict";
+const { Buffer } = require("./bufferPolyfill.js")
 /*!
+
  * This source file is part of the EdgeDB open source project.
+
  *
- * Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
+
+ * Copyright 2020-present MagicStack Inc. and the EdgeDB authors.
+
  *
+
  * Licensed under the Apache License, Version 2.0 (the "License");
+
  * you may not use this file except in compliance with the License.
+
  * You may obtain a copy of the License at
+
  *
+
  *     http://www.apache.org/licenses/LICENSE-2.0
+
  *
+
  * Unless required by applicable law or agreed to in writing, software
+
  * distributed under the License is distributed on an "AS IS" BASIS,
+
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+
  * See the License for the specific language governing permissions and
+
  * limitations under the License.
+
  */
+
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.XOR = exports.getServerKey = exports.getClientKey = exports.getSaltedPassword = exports.buildClientFinalMessage = exports.parseServerFinalMessage = exports.parseServerFirstMessage = exports.buildClientFirstMessage = exports.generateNonce = exports.saslprep = exports.HMAC = exports.H = void 0;
-const adapter_node_1 = require("./adapter.node");
-Object.defineProperty(exports, "H", { enumerable: true, get: function () { return adapter_node_1.H; } });
-Object.defineProperty(exports, "HMAC", { enumerable: true, get: function () { return adapter_node_1.HMAC; } });
-const RAW_NONCE_LENGTH = 18;
-function saslprep(str) {
-    return str.normalize("NFKC");
-}
-exports.saslprep = saslprep;
-async function generateNonce(length = RAW_NONCE_LENGTH) {
-    return await (0, adapter_node_1.randomBytes)(length);
-}
-exports.generateNonce = generateNonce;
-function buildClientFirstMessage(clientNonce, username) {
-    const bare = `n=${saslprep(username)},r=${clientNonce.toString("base64")}`;
-    return [`n,,${bare}`, bare];
-}
-exports.buildClientFirstMessage = buildClientFirstMessage;
-function parseServerFirstMessage(msg) {
-    const attrs = msg.split(",");
-    if (attrs.length < 3) {
-        throw new Error("malformed SCRAM message");
-    }
-    const nonceAttr = attrs[0];
-    if (!nonceAttr || nonceAttr[0] !== "r") {
-        throw new Error("malformed SCRAM message");
-    }
-    const nonceB64 = nonceAttr.split("=", 2)[1];
-    if (!nonceB64) {
-        throw new Error("malformed SCRAM message");
-    }
-    const nonce = Buffer.from(nonceB64, "base64");
-    const saltAttr = attrs[1];
-    if (!saltAttr || saltAttr[0] !== "s") {
-        throw new Error("malformed SCRAM message");
-    }
-    const saltB64 = saltAttr.split("=", 2)[1];
-    if (!saltB64) {
-        throw new Error("malformed SCRAM message");
-    }
-    const salt = Buffer.from(saltB64, "base64");
-    const iterAttr = attrs[2];
-    if (!iterAttr || iterAttr[0] !== "i") {
-        throw new Error("malformed SCRAM message");
-    }
-    const iter = iterAttr.split("=", 2)[1];
-    if (!iter || !iter.match(/^[0-9]*$/)) {
-        throw new Error("malformed SCRAM message");
+
+exports.versionGreaterThanOrEqual = exports.versionGreaterThan = exports.sleep = exports.getUniqueId = void 0;
+
+const idCounter = {};
+
+function getUniqueId(prefix = "") {
+
+    if (!idCounter[prefix]) {
+
+        idCounter[prefix] = 0;
+
     }
-    const iterCount = parseInt(iter, 10);
-    if (iterCount <= 0) {
-        throw new Error("malformed SCRAM message");
-    }
-    return [nonce, salt, iterCount];
-}
-exports.parseServerFirstMessage = parseServerFirstMessage;
-function parseServerFinalMessage(msg) {
-    const attrs = msg.split(",");
-    if (attrs.length < 1) {
-        throw new Error("malformed SCRAM message");
-    }
-    const nonceAttr = attrs[0];
-    if (!nonceAttr || nonceAttr[0] !== "v") {
-        throw new Error("malformed SCRAM message");
-    }
-    const signatureB64 = nonceAttr.split("=", 2)[1];
-    if (!signatureB64) {
-        throw new Error("malformed SCRAM message");
-    }
-    const sig = Buffer.from(signatureB64, "base64");
-    return sig;
+
+    const id = ++idCounter[prefix];
+
+    return `_edgedb_${prefix}_${id.toString(16)}_`;
+
 }
-exports.parseServerFinalMessage = parseServerFinalMessage;
-function buildClientFinalMessage(password, salt, iterations, clientFirstBare, serverFirst, serverNonce) {
-    const clientFinal = `c=biws,r=${serverNonce.toString("base64")}`;
-    const authMessage = Buffer.from(`${clientFirstBare},${serverFirst},${clientFinal}`, "utf8");
-    const saltedPassword = getSaltedPassword(Buffer.from(saslprep(password), "utf8"), salt, iterations);
-    const clientKey = getClientKey(saltedPassword);
-    const storedKey = (0, adapter_node_1.H)(clientKey);
-    const clientSignature = (0, adapter_node_1.HMAC)(storedKey, authMessage);
-    const clientProof = XOR(clientKey, clientSignature);
-    const serverKey = getServerKey(saltedPassword);
-    const serverProof = (0, adapter_node_1.HMAC)(serverKey, authMessage);
-    return [`${clientFinal},p=${clientProof.toString("base64")}`, serverProof];
+
+exports.getUniqueId = getUniqueId;
+
+function sleep(durationMillis) {
+
+    return new Promise((accept) => {
+
+        setTimeout(() => accept(), durationMillis);
+
+    });
+
 }
-exports.buildClientFinalMessage = buildClientFinalMessage;
-function getSaltedPassword(password, salt, iterations) {
-    let Hi = (0, adapter_node_1.HMAC)(password, salt, Buffer.from("00000001", "hex"));
-    let Ui = Hi;
-    for (let _ = 0; _ < iterations - 1; _++) {
-        Ui = (0, adapter_node_1.HMAC)(password, Ui);
-        Hi = XOR(Hi, Ui);
+
+exports.sleep = sleep;
+
+function versionGreaterThan(left, right) {
+
+    if (left[0] > right[0]) {
+
+        return true;
+
     }
-    return Hi;
-}
-exports.getSaltedPassword = getSaltedPassword;
-function getClientKey(saltedPassword) {
-    return (0, adapter_node_1.HMAC)(saltedPassword, Buffer.from("Client Key", "utf8"));
-}
-exports.getClientKey = getClientKey;
-function getServerKey(saltedPassword) {
-    return (0, adapter_node_1.HMAC)(saltedPassword, Buffer.from("Server Key", "utf8"));
-}
-exports.getServerKey = getServerKey;
-function XOR(a, b) {
-    const len = a.length;
-    if (len !== b.length) {
-        throw new Error("scram.XOR: buffers are of different lengths");
+
+    if (left[0] < right[0]) {
+
+        return false;
+
     }
-    const res = Buffer.allocUnsafe(len);
-    for (let i = 0; i < len; i++) {
-        res[i] = a[i] ^ b[i];
+
+    return left[1] > right[1];
+
+}
+
+exports.versionGreaterThan = versionGreaterThan;
+
+function versionGreaterThanOrEqual(left, right) {
+
+    if (left[0] === right[0] && left[1] === right[1]) {
+
+        return true;
+
     }
-    return res;
+
+    return versionGreaterThan(left, right);
+
 }
-exports.XOR = XOR;
+
+exports.versionGreaterThanOrEqual = versionGreaterThanOrEqual;
diff --git a/node_modules/edgedb/dist/syntax/select.js b/node_modules/edgedb/dist/syntax/select.js
index 4e6d4b4..9a503a3 100644
--- a/node_modules/edgedb/dist/syntax/select.js
+++ b/node_modules/edgedb/dist/syntax/select.js
@@ -1,269 +1,537 @@
 "use strict";
+const { Buffer } = require("../bufferPolyfill.js")
 Object.defineProperty(exports, "__esModule", { value: true });
+
 exports.select = exports.$existingScopes = exports.$selectify = exports.delete = exports.$handleModifiers = exports.is = exports.EMPTY_LAST = exports.EMPTY_FIRST = exports.DESC = exports.ASC = void 0;
+
 const edgedb_1 = require("edgedb");
+
 const reflection_1 = require("../reflection");
+
 const path_1 = require("./path");
+
 const literal_1 = require("./literal");
+
 const __spec__1 = require("@generated/__spec__");
+
 const castMaps_1 = require("@generated/castMaps");
+
 exports.ASC = "ASC";
+
 exports.DESC = "DESC";
+
 exports.EMPTY_FIRST = "EMPTY FIRST";
+
 exports.EMPTY_LAST = "EMPTY LAST";
+
 function is(expr, shape) {
+
     const mappedShape = {};
+
     for (const [key, value] of Object.entries(shape)) {
+
         mappedShape[key] = {
+
             __kind__: reflection_1.ExpressionKind.PolyShapeElement,
+
             __polyType__: expr,
+
             __shapeElement__: value,
+
         };
+
     }
+
     return mappedShape;
+
 }
+
 exports.is = is;
+
 function computeFilterCardinality(expr, cardinality, base) {
+
     var _a, _b, _c;
+
     let card = cardinality;
+
     const filter = expr;
+
     const baseIsObjectExpr = ((_a = base === null || base === void 0 ? void 0 : base.__element__) === null || _a === void 0 ? void 0 : _a.__kind__) === reflection_1.TypeKind.object;
+
     const filterExprIsEq = filter.__kind__ === reflection_1.ExpressionKind.Operator && filter.__name__ === "=";
+
     const arg0 = (_b = filter === null || filter === void 0 ? void 0 : filter.__args__) === null || _b === void 0 ? void 0 : _b[0];
+
     const arg1 = (_c = filter === null || filter === void 0 ? void 0 : filter.__args__) === null || _c === void 0 ? void 0 : _c[1];
+
     const argsExist = !!arg0 && !!arg1 && !!arg1.__cardinality__;
+
     const arg0IsUnique = (arg0 === null || arg0 === void 0 ? void 0 : arg0.__exclusive__) === true;
+
     if (baseIsObjectExpr && filterExprIsEq && argsExist && arg0IsUnique) {
+
         const newCard = arg1.__cardinality__ === reflection_1.Cardinality.One ||
+
             arg1.__cardinality__ === reflection_1.Cardinality.AtMostOne
+
             ? reflection_1.Cardinality.AtMostOne
+
             : arg1.__cardinality__ === reflection_1.Cardinality.Empty
+
                 ? reflection_1.Cardinality.Empty
+
                 : cardinality;
+
         if (arg0.__kind__ === reflection_1.ExpressionKind.PathLeaf) {
+
             const arg0ParentMatchesBase = arg0.__parent__.type.__element__.__name__ ===
+
                 base.__element__.__name__;
+
             if (arg0ParentMatchesBase) {
+
                 card = newCard;
+
             }
+
         }
+
         else if (arg0.__kind__ === reflection_1.ExpressionKind.PathNode) {
+
             const parent = arg0.__parent__;
+
             if (parent === null) {
+
                 const arg0MatchesBase = arg0.__element__.__name__ === base.__element__.__name__;
+
                 if (arg0MatchesBase) {
+
                     card = newCard;
+
                 }
+
             }
+
             else {
+
                 const arg0ParentMatchesBase = (parent === null || parent === void 0 ? void 0 : parent.type.__element__.__name__) === base.__element__.__name__;
+
                 if (arg0ParentMatchesBase) {
+
                     card = newCard;
+
                 }
+
             }
+
         }
+
     }
+
     return card;
+
 }
+
 function $handleModifiers(modifiers, rootExpr) {
+
     const mods = { ...modifiers };
+
     let card = rootExpr.__cardinality__;
+
     if (mods.filter && rootExpr.__element__.__kind__ === reflection_1.TypeKind.object) {
+
         card = computeFilterCardinality(mods.filter, card, rootExpr);
+
     }
+
     if (mods.order_by) {
+
         const orderExprs = Array.isArray(mods.order_by)
+
             ? mods.order_by
+
             : [mods.order_by];
+
         mods.order_by = orderExprs.map(expr => typeof expr.__element__ === "undefined"
+
             ? expr
+
             : { expression: expr });
+
     }
+
     if (mods.offset) {
+
         mods.offset =
+
             typeof mods.offset === "number"
+
                 ? (0, literal_1.$getTypeByName)("std::number")(mods.offset)
+
                 : mods.offset;
+
         card = reflection_1.cardinalityUtil.overrideLowerBound(card, "Zero");
+
     }
+
     if (mods.limit) {
+
         let expr = mods.limit;
+
         if (typeof expr === "number") {
+
             expr = (0, literal_1.$getTypeByName)("std::number")(expr);
+
         }
+
         else if (expr.__kind__ === reflection_1.ExpressionKind.Set) {
+
             expr = expr.__exprs__[0];
+
         }
+
         mods.limit = expr;
+
         card = reflection_1.cardinalityUtil.overrideLowerBound(card, "Zero");
+
     }
+
     return { modifiers: mods, cardinality: card };
+
 }
+
 exports.$handleModifiers = $handleModifiers;
+
 function deleteExpr(expr, modifiersGetter) {
+
     const selectExpr = select(expr, modifiersGetter);
+
     return (0, path_1.$expressionify)({
+
         __kind__: reflection_1.ExpressionKind.Delete,
+
         __element__: selectExpr.__element__,
+
         __cardinality__: selectExpr.__cardinality__,
+
         __expr__: selectExpr,
+
     });
+
 }
+
 exports.delete = deleteExpr;
+
 function $selectify(expr) {
+
     return expr;
+
 }
+
 exports.$selectify = $selectify;
+
 const $FreeObject = (0, reflection_1.makeType)(__spec__1.spec, [...__spec__1.spec.values()].find(s => s.name === "std::FreeObject").id, literal_1.literal);
+
 const FreeObject = {
+
     __kind__: reflection_1.ExpressionKind.PathNode,
+
     __element__: $FreeObject,
+
     __cardinality__: reflection_1.Cardinality.One,
+
     __parent__: null,
+
     __exclusive__: true,
+
     __scopeRoot__: null,
+
 };
+
 exports.$existingScopes = new Set();
+
 function select(...args) {
+
     const firstArg = args[0];
+
     if (typeof firstArg !== "object" ||
+
         firstArg instanceof Buffer ||
+
         firstArg instanceof Date ||
+
         firstArg instanceof edgedb_1.Duration ||
+
         firstArg instanceof edgedb_1.LocalDateTime ||
+
         firstArg instanceof edgedb_1.LocalDate ||
+
         firstArg instanceof edgedb_1.LocalTime ||
+
         firstArg instanceof edgedb_1.RelativeDuration ||
+
         firstArg instanceof edgedb_1.ConfigMemory) {
+
         const literalExpr = (0, castMaps_1.literalToTypeSet)(firstArg);
+
         return (0, path_1.$expressionify)($selectify({
+
             __kind__: reflection_1.ExpressionKind.Select,
+
             __element__: literalExpr.__element__,
+
             __cardinality__: literalExpr.__cardinality__,
+
             __expr__: literalExpr,
+
             __modifiers__: {},
+
         }));
+
     }
+
     const [expr, shapeGetter] = typeof args[0].__element__ !== "undefined"
+
         ? args
+
         : [FreeObject, () => args[0]];
+
     if (!shapeGetter) {
+
         if (expr.__element__.__kind__ === reflection_1.TypeKind.object) {
+
             const objectExpr = expr;
+
             return (0, path_1.$expressionify)($selectify({
+
                 __kind__: reflection_1.ExpressionKind.Select,
+
                 __element__: {
+
                     __kind__: reflection_1.TypeKind.object,
+
                     __name__: `${objectExpr.__element__.__name__}`,
+
                     __pointers__: objectExpr.__element__.__pointers__,
+
                     __shape__: objectExpr.__element__.__shape__,
+
                 },
+
                 __cardinality__: objectExpr.__cardinality__,
+
                 __expr__: objectExpr,
+
                 __modifiers__: {},
+
             }));
+
         }
+
         else {
+
             return (0, path_1.$expressionify)($selectify({
+
                 __kind__: reflection_1.ExpressionKind.Select,
+
                 __element__: expr.__element__,
+
                 __cardinality__: expr.__cardinality__,
+
                 __expr__: expr,
+
                 __modifiers__: {},
+
             }));
+
         }
+
     }
+
     const cleanScopedExprs = exports.$existingScopes.size === 0;
+
     const { modifiers: mods, shape, scope } = resolveShape(shapeGetter, expr);
+
     if (cleanScopedExprs) {
+
         exports.$existingScopes.clear();
+
     }
+
     const { modifiers, cardinality } = $handleModifiers(mods, expr);
+
     return (0, path_1.$expressionify)($selectify({
+
         __kind__: reflection_1.ExpressionKind.Select,
+
         __element__: expr !== scope
+
             ? {
+
                 __kind__: reflection_1.TypeKind.object,
+
                 __name__: `${expr.__element__.__name__}`,
+
                 __pointers__: expr.__element__.__pointers__,
+
                 __shape__: shape,
+
             }
+
             : expr.__element__,
+
         __cardinality__: cardinality,
+
         __expr__: expr,
+
         __modifiers__: modifiers,
+
         __scope__: expr !== scope && expr.__element__.__name__ !== "std::FreeObject"
+
             ? scope
+
             : undefined,
+
     }));
+
 }
+
 exports.select = select;
+
 function resolveShape(shapeGetter, expr) {
+
     const modifiers = {};
+
     const shape = {};
+
     const scope = expr.__element__.__kind__ === reflection_1.TypeKind.object
+
         ? (0, path_1.$getScopedExpr)(expr, exports.$existingScopes)
+
         : expr;
+
     const selectShape = typeof shapeGetter === "function" ? shapeGetter(scope) : shapeGetter;
+
     for (const [key, value] of Object.entries(selectShape)) {
+
         if (key === "filter" ||
+
             key === "order_by" ||
+
             key === "offset" ||
+
             key === "limit") {
+
             modifiers[key] = value;
+
         }
+
         else {
+
             if (scope === expr) {
+
                 throw new Error(`Invalid select shape key '${key}' on scalar expression, ` +
+
                     `only modifiers are allowed (filter, order_by, offset and limit)`);
+
             }
+
             shape[key] = resolveShapeElement(key, value, scope);
+
         }
+
     }
+
     return { shape, modifiers, scope };
+
 }
+
 function resolveShapeElement(key, value, scope) {
+
     var _a, _b;
+
     if ((typeof value === "function" &&
+
         ((_a = scope.__element__.__pointers__[key]) === null || _a === void 0 ? void 0 : _a.__kind__) === "link") ||
+
         (typeof value === "object" &&
+
             typeof value.__kind__ === "undefined")) {
+
         const childExpr = scope[key];
+
         const { shape: childShape, scope: childScope, modifiers: mods, } = resolveShape(value, childExpr);
+
         const { modifiers } = $handleModifiers(mods, childExpr);
+
         return {
+
             __kind__: reflection_1.ExpressionKind.Select,
+
             __element__: {
+
                 __kind__: reflection_1.TypeKind.object,
+
                 __name__: `${childExpr.__element__.__name__}`,
+
                 __pointers__: childExpr.__element__.__pointers__,
+
                 __shape__: childShape,
+
             },
+
             __cardinality__: scope.__element__.__pointers__[key].cardinality,
+
             __expr__: childExpr,
+
             __modifiers__: modifiers,
+
             __scope__: childScope,
+
         };
+
     }
+
     else if (((_b = value) === null || _b === void 0 ? void 0 : _b.__kind__) === reflection_1.ExpressionKind.PolyShapeElement) {
+
         const polyElement = value;
+
         const polyScope = scope.is(polyElement.__polyType__);
+
         return {
+
             __kind__: reflection_1.ExpressionKind.PolyShapeElement,
+
             __polyType__: polyScope,
+
             __shapeElement__: resolveShapeElement(key, polyElement.__shapeElement__, polyScope),
+
         };
+
     }
+
     else if (typeof value === "boolean" && key.startsWith("@")) {
+
         const linkProp = scope[key];
+
         if (!linkProp) {
+
             throw new Error(scope.__parent__
+
                 ? `link property '${key}' does not exist on link ${scope.__parent__.linkName}`
+
                 : `cannot select link property '${key}' on an object (${scope.__element__.__name__})`);
+
         }
+
         return value ? linkProp : false;
+
     }
+
     else {
+
         return value;
+
     }
+
 }
diff --git a/node_modules/edgedb/dist/syntax/toEdgeQL.js b/node_modules/edgedb/dist/syntax/toEdgeQL.js
index 7e573c9..ee310f3 100644
--- a/node_modules/edgedb/dist/syntax/toEdgeQL.js
+++ b/node_modules/edgedb/dist/syntax/toEdgeQL.js
@@ -1,933 +1,1865 @@
 "use strict";
+const { Buffer } = require("../bufferPolyfill.js")
 Object.defineProperty(exports, "__esModule", { value: true });
+
 exports.$toEdgeQL = void 0;
+
 const edgedb_1 = require("edgedb");
+
 const reflection_1 = require("../reflection");
+
 const reservedKeywords_1 = require("../reflection/reservedKeywords");
+
 function shapeToEdgeQL(shape, ctx, pointerKeys = null, keysOnly = false) {
+
     if (shape === null) {
+
         return ``;
+
     }
+
     const lines = [];
+
     const addLine = (line) => lines.push(`${keysOnly ? "" : "  "}${line}`);
+
     const seen = new Set();
+
     for (const key in shape) {
+
         if (!shape.hasOwnProperty(key))
+
             continue;
+
         if (seen.has(key)) {
+
             console.warn(`Invalid: duplicate key "${key}"`);
+
             continue;
+
         }
+
         seen.add(key);
+
         let val = shape[key];
+
         let operator = ":=";
+
         let polyType = null;
+
         if (typeof val === "object" && !val.__element__) {
+
             if (!!val["+="]) {
+
                 operator = "+=";
+
                 val = val["+="];
+
             }
+
             else if (!!val["-="]) {
+
                 operator = "-=";
+
                 val = val["-="];
+
             }
+
         }
+
         if (val.__kind__ === reflection_1.ExpressionKind.PolyShapeElement) {
+
             polyType = val.__polyType__;
+
             val = val.__shapeElement__;
+
         }
+
         const polyIntersection = polyType
+
             ? `[IS ${polyType.__element__.__name__}].`
+
             : "";
+
         if (typeof val === "boolean") {
+
             if (val) {
+
                 addLine(`${polyIntersection}${q(key)}`);
+
             }
+
         }
+
         else if (val.hasOwnProperty("__kind__")) {
+
             if (keysOnly) {
+
                 addLine(q(key) +
+
                     ((0, reflection_1.isObjectType)(val.__element__)
+
                         ? `: ${shapeToEdgeQL(val.__element__.__shape__, ctx, null, true)}`
+
                         : ""));
+
                 continue;
+
             }
+
             const renderedExpr = renderEdgeQL(val, ctx);
+
             const expectedCardinality = pointerKeys &&
+
                 !pointerKeys.includes(key) &&
+
                 val.hasOwnProperty("__cardinality__")
+
                 ? val.__cardinality__ === reflection_1.Cardinality.Many ||
+
                     val.__cardinality__ === reflection_1.Cardinality.AtLeastOne
+
                     ? "multi "
+
                     : "single "
+
                 : "";
+
             addLine(`${expectedCardinality}${q(key)} ${operator} ${renderedExpr.includes("\n")
+
                 ? `(\n${indent(renderedExpr[0] === "(" &&
+
                     renderedExpr[renderedExpr.length - 1] === ")"
+
                     ? renderedExpr.slice(1, -1)
+
                     : renderedExpr, 4)}\n  )`
+
                 : renderedExpr}`);
+
         }
+
         else {
+
             throw new Error(`Invalid shape element at "${key}".`);
+
         }
+
     }
+
     if (lines.length === 0) {
+
         addLine("id");
+
     }
+
     return keysOnly ? `{${lines.join(", ")}}` : `{\n${lines.join(",\n")}\n}`;
+
 }
+
 const toEdgeQLCache = new WeakMap();
+
 function $toEdgeQL() {
+
     var _a;
+
     if (toEdgeQLCache.has(this)) {
+
         return toEdgeQLCache.get(this);
+
     }
+
     const walkExprCtx = {
+
         seen: new Map(),
+
         rootScope: null,
+
     };
+
     walkExprTree(this, null, walkExprCtx);
+
     const withBlocks = new Map();
+
     const withVars = new Map();
+
     const seen = new Map(walkExprCtx.seen);
+
     const linkProps = new Map();
+
     for (const [expr, refData] of seen) {
+
         seen.delete(expr);
+
         if (refData.linkProps.length) {
+
             linkProps.set(expr, refData.linkProps.map(linkProp => linkProp.__parent__.linkName.slice(1)));
+
         }
+
         if (withVars.has(expr) ||
+
             ((expr.__kind__ === reflection_1.ExpressionKind.PathLeaf ||
+
                 expr.__kind__ === reflection_1.ExpressionKind.PathNode ||
+
                 expr.__kind__ === reflection_1.ExpressionKind.TypeIntersection) &&
+
                 !refData.boundScope) ||
+
             expr.__kind__ === reflection_1.ExpressionKind.ForVar ||
+
             expr.__kind__ === reflection_1.ExpressionKind.Param) {
+
             continue;
+
         }
+
         if ((expr.__kind__ === reflection_1.ExpressionKind.Select ||
+
             expr.__kind__ === reflection_1.ExpressionKind.Update) &&
+
             expr.__scope__ &&
+
             !withVars.has(expr.__scope__)) {
+
             const withBlock = expr;
+
             const scopeVar = expr.__scope__;
+
             const scopeVarName = `__scope_${withVars.size}_${scopeVar.__element__.__name__.split("::")[1]}`;
+
             withVars.set(scopeVar, {
+
                 name: scopeVarName,
+
                 scope: withBlock,
+
                 childExprs: new Set(),
+
                 scopedExpr: expr.__element__.__kind__ === reflection_1.TypeKind.object
+
                     ? expr.__expr__
+
                     : undefined,
+
             });
+
         }
+
         if (refData.boundScope ||
+
             refData.refCount > 1 ||
+
             refData.aliases.length > 0) {
+
             let withBlock = refData.boundScope;
+
             const parentScopes = [...refData.parentScopes].filter(scope => scope !== null);
+
             if (!withBlock) {
+
                 if (parentScopes.some(parentScope => seen.has(parentScope))) {
+
                     seen.set(expr, refData);
+
                     continue;
+
                 }
+
                 const resolvedParentScopes = parentScopes.map(parentScope => { var _a, _b; return (_b = (_a = withVars.get(parentScope)) === null || _a === void 0 ? void 0 : _a.scope) !== null && _b !== void 0 ? _b : parentScope; });
+
                 withBlock =
+
                     (_a = resolvedParentScopes.find(parentScope => {
+
                         const childExprs = new Set(walkExprCtx.seen.get(parentScope).childExprs);
+
                         return resolvedParentScopes.every(scope => scope === parentScope || childExprs.has(scope));
+
                     })) !== null && _a !== void 0 ? _a : walkExprCtx.rootScope;
+
             }
+
             if (!withBlock) {
+
                 throw new Error(`Cannot extract repeated expression into 'WITH' block, ` +
+
                     `query has no 'WITH'able expressions`);
+
             }
+
             if (!withBlocks.has(withBlock)) {
+
                 withBlocks.set(withBlock, new Set());
+
             }
+
             const validScopes = new Set([
+
                 withBlock,
+
                 ...walkExprCtx.seen.get(withBlock).childExprs,
+
             ]);
+
             for (const scope of [
+
                 ...refData.parentScopes,
+
                 ...reflection_1.util.flatMap(refData.aliases, alias => [
+
                     ...walkExprCtx.seen.get(alias).parentScopes,
+
                 ]),
+
             ]) {
+
                 if (scope === null || !validScopes.has(scope)) {
+
                     throw new Error(refData.boundScope
+
                         ? `Expr or it's aliases used outside of declared 'WITH' block scope`
+
                         : `Cannot extract repeated or aliased expression into 'WITH' block, ` +
+
                             `expression or it's aliases appear outside root scope`);
+
                 }
+
             }
+
             for (const withVar of [expr, ...refData.aliases]) {
+
                 const withVarBoundScope = walkExprCtx.seen.get(withVar).boundScope;
+
                 if (withVarBoundScope && withVarBoundScope !== refData.boundScope) {
+
                     continue;
+
                 }
+
                 const withVarName = `__withVar_${withVars.size}`;
+
                 withBlocks.get(withBlock).add(withVar);
+
                 withVars.set(withVar, {
+
                     name: withVarName,
+
                     scope: withBlock,
+
                     childExprs: new Set(walkExprCtx.seen.get(withVar).childExprs),
+
                 });
+
             }
+
         }
+
     }
+
     let edgeQL = renderEdgeQL(this, {
+
         withBlocks,
+
         withVars,
+
         forVars: new Map(),
+
         linkProps,
+
     });
+
     if (edgeQL.startsWith("(") &&
+
         edgeQL.endsWith(")") &&
+
         !(this.__kind__ === reflection_1.ExpressionKind.Tuple ||
+
             this.__kind__ === reflection_1.ExpressionKind.NamedTuple ||
+
             this.__kind__ === reflection_1.ExpressionKind.Literal)) {
+
         edgeQL = edgeQL.slice(1, -1);
+
     }
+
     toEdgeQLCache.set(this, edgeQL);
+
     return edgeQL;
+
 }
+
 exports.$toEdgeQL = $toEdgeQL;
+
 function topoSortWithVars(vars, ctx) {
+
     if (!vars.size) {
+
         return [];
+
     }
+
     const sorted = [];
+
     const unvisited = new Set(vars);
+
     const visiting = new Set();
+
     for (const withVar of unvisited) {
+
         visit(withVar);
+
     }
+
     function visit(withVar) {
+
         if (!unvisited.has(withVar)) {
+
             return;
+
         }
+
         if (visiting.has(withVar)) {
+
             throw new Error(`'WITH' variables contain a cyclic dependency`);
+
         }
+
         visiting.add(withVar);
+
         for (const child of ctx.withVars.get(withVar).childExprs) {
+
             if (vars.has(child)) {
+
                 visit(child);
+
             }
+
         }
+
         visiting.delete(withVar);
+
         unvisited.delete(withVar);
+
         sorted.push(withVar);
+
     }
+
     return sorted;
+
 }
+
 function renderEdgeQL(_expr, ctx, renderShape = true, noImplicitDetached = false) {
+
     var _a, _b;
+
     if (!_expr.__kind__) {
+
         throw new Error("Invalid expression.");
+
     }
+
     const expr = _expr;
+
     const withVar = ctx.withVars.get(expr);
+
     if (withVar && ctx.renderWithVar !== expr) {
+
         return renderShape &&
+
             expr.__kind__ === reflection_1.ExpressionKind.Select &&
+
             (0, reflection_1.isObjectType)(expr.__element__)
+
             ? `(${withVar.name} ${shapeToEdgeQL((expr.__element__.__shape__ || {}), ctx, null, true)})`
+
             : withVar.name;
+
     }
+
     function renderWithBlockExpr(varExpr, _noImplicitDetached) {
+
         var _a;
+
         const withBlockElement = ctx.withVars.get(varExpr);
+
         let renderedExpr = renderEdgeQL((_a = withBlockElement.scopedExpr) !== null && _a !== void 0 ? _a : varExpr, {
+
             ...ctx,
+
             renderWithVar: varExpr,
+
         }, !withBlockElement.scopedExpr, _noImplicitDetached);
+
         if (ctx.linkProps.has(expr)) {
+
             renderedExpr = `(SELECT ${renderedExpr} {\n${ctx.linkProps
+
                 .get(expr)
+
                 .map(linkPropName => `  __linkprop_${linkPropName} := ${renderedExpr}@${linkPropName}`)
+
                 .join(",\n")}\n})`;
+
         }
+
         return `  ${withBlockElement.name} := ${renderedExpr.includes("\n")
+
             ? `(\n${indent(renderedExpr[0] === "(" &&
+
                 renderedExpr[renderedExpr.length - 1] === ")"
+
                 ? renderedExpr.slice(1, -1)
+
                 : renderedExpr, 4)}\n  )`
+
             : renderedExpr}`;
+
     }
+
     let withBlock = "";
+
     const scopeExpr = (expr.__kind__ === reflection_1.ExpressionKind.Select ||
+
         expr.__kind__ === reflection_1.ExpressionKind.Update) &&
+
         ctx.withVars.has(expr.__scope__)
+
         ? expr.__scope__
+
         : undefined;
+
     if (ctx.withBlocks.has(expr) || scopeExpr) {
+
         let blockVars = topoSortWithVars((_a = ctx.withBlocks.get(expr)) !== null && _a !== void 0 ? _a : new Set(), ctx);
+
         const scopedWithBlock = [];
+
         if (scopeExpr) {
+
             const scopeVar = ctx.withVars.get(scopeExpr);
+
             const scopedBlockVars = blockVars.filter(blockVarExpr => { var _a; return (_a = ctx.withVars.get(blockVarExpr)) === null || _a === void 0 ? void 0 : _a.childExprs.has(scopeExpr); });
+
             blockVars = blockVars.filter(blockVar => !scopedBlockVars.includes(blockVar));
+
             if (scopedBlockVars.length) {
+
                 const scopeName = scopeVar.name;
+
                 scopeVar.name = scopeName + "_expr";
+
                 scopedWithBlock.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));
+
                 scopeVar.name = scopeName + "_inner";
+
                 scopedWithBlock.push(`  ${scopeName} := (FOR ${scopeVar.name} IN {${scopeName + "_expr"}} UNION (\n    WITH\n${indent(scopedBlockVars
+
                     .map(blockVar => renderWithBlockExpr(blockVar))
+
                     .join(",\n"), 4)}\n    SELECT ${scopeVar.name} {\n${scopedBlockVars
+
                     .map(blockVar => {
+
                     const name = ctx.withVars.get(blockVar).name;
+
                     return `      ${name} := ${name}`;
+
                 })
+
                     .join(",\n")}\n    }\n  ))`);
+
                 scopeVar.name = scopeName;
+
                 for (const blockVarExpr of scopedBlockVars) {
+
                     const blockVar = ctx.withVars.get(blockVarExpr);
+
                     blockVar.name = `${scopeName}.${blockVar.name}`;
+
                 }
+
             }
+
             else {
+
                 scopedWithBlock.push(renderWithBlockExpr(scopeExpr, noImplicitDetached));
+
             }
+
         }
+
         withBlock = `WITH\n${[
+
             ...blockVars.map(blockVar => renderWithBlockExpr(blockVar)),
+
             ...scopedWithBlock,
+
         ].join(",\n")}\n`;
+
     }
+
     if (expr.__kind__ === reflection_1.ExpressionKind.With) {
+
         return renderEdgeQL(expr.__expr__, ctx);
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.WithParams) {
+
         return `(WITH\n${expr.__params__
+
             .map(param => {
+
             const optional = param.__cardinality__ === reflection_1.Cardinality.AtMostOne ? "OPTIONAL " : "";
+
             return `  __param__${param.__name__} := ${param.__isComplex__
+
                 ? `<${param.__element__.__name__}><${optional}json>`
+
                 : `<${optional}${param.__element__.__name__}>`}$${param.__name__}`;
+
         })
+
             .join(",\n")}\nSELECT ${renderEdgeQL(expr.__expr__, ctx)})`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Alias) {
+
         const aliasedExprVar = ctx.withVars.get(expr.__expr__);
+
         if (!aliasedExprVar) {
+
             throw new Error(`Expression referenced by alias does not exist in 'WITH' block`);
+
         }
+
         return aliasedExprVar.name;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.PathNode ||
+
         expr.__kind__ === reflection_1.ExpressionKind.PathLeaf) {
+
         if (!expr.__parent__) {
+
             return `${noImplicitDetached ? "" : "DETACHED "}${expr.__element__.__name__}`;
+
         }
+
         else {
+
             const isScopedLinkProp = expr.__parent__.linkName.startsWith("@") &&
+
                 ctx.withVars.has(expr.__parent__.type);
+
             const linkName = isScopedLinkProp
+
                 ? `__linkprop_${expr.__parent__.linkName.slice(1)}`
+
                 : expr.__parent__.linkName;
+
             const parent = renderEdgeQL(expr.__parent__.type, ctx, false, noImplicitDetached);
+
             return `${parent}${linkName.startsWith("@") ? "" : "."}${q(linkName)}`;
+
         }
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Literal) {
+
         return literalToEdgeQL(expr.__element__, expr.__value__);
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Set) {
+
         const exprs = expr.__exprs__;
+
         if (exprs.every(ex => ex.__element__.__kind__ === reflection_1.TypeKind.object) ||
+
             exprs.every(ex => ex.__element__.__kind__ !== reflection_1.TypeKind.object)) {
+
             if (exprs.length === 0)
+
                 return `<${expr.__element__.__name__}>{}`;
+
             return `{ ${exprs.map(ex => renderEdgeQL(ex, ctx)).join(", ")} }`;
+
         }
+
         else {
+
             throw new Error(`Invalid arguments to set constructor: ${exprs
+
                 .map(ex => ex.__element__.__name__)
+
                 .join(", ")}`);
+
         }
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Array) {
+
         return `[${expr.__items__
+
             .map(item => renderEdgeQL(item, ctx))
+
             .join(", ")}]`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Tuple) {
+
         return `(\n${expr.__items__
+
             .map(item => `  ` + renderEdgeQL(item, ctx, renderShape, noImplicitDetached))
+
             .join(",\n")}${expr.__items__.length === 1 ? "," : ""}\n)`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.NamedTuple) {
+
         return `(\n${Object.keys(expr.__shape__)
+
             .map(key => `  ${key} := ${renderEdgeQL(expr.__shape__[key], ctx, renderShape, noImplicitDetached)}`)
+
             .join(",\n")}\n)`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.TuplePath) {
+
         return `${renderEdgeQL(expr.__parent__, ctx)}.${expr.__index__}`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Cast) {
+
         if (expr.__expr__ === null) {
+
             return `<${expr.__element__.__name__}>{}`;
+
         }
+
         return `<${expr.__element__.__name__}>(${renderEdgeQL(expr.__expr__, ctx)})`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Select) {
+
         const lines = [];
+
         if ((0, reflection_1.isObjectType)(expr.__element__)) {
+
             lines.push(`SELECT${expr.__expr__.__element__.__name__ === "std::FreeObject"
+
                 ? ""
+
                 : ` ${renderEdgeQL((_b = expr.__scope__) !== null && _b !== void 0 ? _b : expr.__expr__, ctx, false)}`}`);
+
             if (expr.__element__.__shape__ !==
+
                 expr.__expr__.__element__.__shape__) {
+
                 lines.push(shapeToEdgeQL((expr.__element__.__shape__ || {}), ctx, Object.keys(expr.__element__.__pointers__)));
+
             }
+
         }
+
         else {
+
             const needsScalarVar = (expr.__modifiers__.filter ||
+
                 expr.__modifiers__.order_by ||
+
                 expr.__modifiers__.offset ||
+
                 expr.__modifiers__.limit) &&
+
                 !ctx.withVars.has(expr.__expr__);
+
             lines.push(`SELECT ${needsScalarVar ? "_ := " : ""}${renderEdgeQL(expr.__expr__, ctx)}`);
+
             if (needsScalarVar) {
+
                 ctx = { ...ctx, withVars: new Map(ctx.withVars) };
+
                 ctx.withVars.set(expr.__expr__, {
+
                     name: "_",
+
                     childExprs: new Set(),
+
                     scope: expr,
+
                 });
+
             }
+
         }
+
         const modifiers = [];
+
         if (expr.__modifiers__.filter) {
+
             modifiers.push(`FILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}`);
+
         }
+
         if (expr.__modifiers__.order_by) {
+
             modifiers.push(...expr.__modifiers__.order_by.map(({ expression, direction, empty }, i) => {
+
                 return `${i === 0 ? "ORDER BY" : "  THEN"} ${renderEdgeQL(expression, ctx)}${direction ? " " + direction : ""}${empty ? " " + empty : ""}`;
+
             }));
+
         }
+
         if (expr.__modifiers__.offset) {
+
             modifiers.push(`OFFSET ${renderEdgeQL(expr.__modifiers__.offset, ctx)}`);
+
         }
+
         if (expr.__modifiers__.limit) {
+
             modifiers.push(`LIMIT ${renderEdgeQL(expr.__modifiers__.limit, ctx)}`);
+
         }
+
         return ("(" +
+
             withBlock +
+
             lines.join(" ") +
+
             (modifiers.length ? "\n" + modifiers.join("\n") : "") +
+
             ")");
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Update) {
+
         return `(${withBlock}UPDATE ${renderEdgeQL(expr.__scope__, ctx, false)}${expr.__modifiers__.filter
+
             ? `\nFILTER ${renderEdgeQL(expr.__modifiers__.filter, ctx)}\n`
+
             : " "}SET ${shapeToEdgeQL(expr.__shape__, ctx)})`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Delete) {
+
         return `(DELETE ${renderEdgeQL(expr.__expr__, ctx, undefined, noImplicitDetached)})`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Insert) {
+
         return `(INSERT ${renderEdgeQL(expr.__expr__, ctx, false, true)} ${shapeToEdgeQL(expr.__shape__, ctx)})`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.InsertUnlessConflict) {
+
         const $on = expr.__conflict__.on;
+
         const $else = expr.__conflict__.else;
+
         const clause = [];
+
         if (!$on) {
+
             clause.push("\nUNLESS CONFLICT");
+
         }
+
         if ($on) {
+
             clause.push(`\nUNLESS CONFLICT ON ${renderEdgeQL($on, ctx, false, true)}`);
+
         }
+
         if ($else) {
+
             clause.push(`\nELSE (${renderEdgeQL($else, ctx, true, true)})`);
+
         }
+
         return `(${renderEdgeQL(expr.__expr__, ctx, false, true).slice(1, -1)} ${clause.join("")})`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Function) {
+
         const args = expr.__args__.map(arg => `${renderEdgeQL(arg, ctx, false)}`);
+
         for (const [key, arg] of Object.entries(expr.__namedargs__)) {
+
             args.push(`${q(key)} := ${renderEdgeQL(arg, ctx, false)}`);
+
         }
+
         return `${expr.__name__}(${args.join(", ")})`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Operator) {
+
         const operator = expr.__name__;
+
         const args = expr.__args__;
+
         switch (expr.__opkind__) {
+
             case reflection_1.OperatorKind.Infix:
+
                 if (operator === "[]") {
+
                     let index = "";
+
                     if (Array.isArray(args[1])) {
+
                         const [start, end] = args[1];
+
                         if (start) {
+
                             index += renderEdgeQL(start, ctx);
+
                         }
+
                         index += ":";
+
                         if (end) {
+
                             index += renderEdgeQL(end, ctx);
+
                         }
+
                     }
+
                     else {
+
                         index = renderEdgeQL(args[1], ctx);
+
                     }
+
                     return `${renderEdgeQL(args[0], ctx)}[${index}]`;
+
                 }
+
                 return `(${renderEdgeQL(args[0], ctx)} ${operator} ${renderEdgeQL(args[1], ctx)})`;
+
             case reflection_1.OperatorKind.Postfix:
+
                 return `(${renderEdgeQL(args[0], ctx)} ${operator})`;
+
             case reflection_1.OperatorKind.Prefix:
+
                 return `(${operator} ${renderEdgeQL(args[0], ctx)})`;
+
             case reflection_1.OperatorKind.Ternary:
+
                 if (operator === "if_else") {
+
                     return `(${renderEdgeQL(args[0], ctx)} IF ${renderEdgeQL(args[1], ctx)} ELSE ${renderEdgeQL(args[2], ctx)})`;
+
                 }
+
                 else {
+
                     throw new Error(`Unknown operator: ${operator}`);
+
                 }
+
             default:
+
                 reflection_1.util.assertNever(expr.__opkind__, new Error(`Unknown operator kind: ${expr.__opkind__}`));
+
         }
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.TypeIntersection) {
+
         return `${renderEdgeQL(expr.__expr__, ctx)}[IS ${expr.__element__.__name__}]`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.For) {
+
         ctx.forVars.set(expr.__forVar__, `__forVar__${ctx.forVars.size}`);
+
         return `(${withBlock}FOR ${ctx.forVars.get(expr.__forVar__)} IN {${renderEdgeQL(expr.__iterSet__, ctx)}}
+
 UNION (\n${indent(renderEdgeQL(expr.__expr__, ctx), 2)}\n))`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.ForVar) {
+
         const forVar = ctx.forVars.get(expr);
+
         if (!forVar) {
+
             throw new Error(`'FOR' loop variable used outside of 'FOR' loop`);
+
         }
+
         return forVar;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Param) {
+
         return `__param__${expr.__name__}`;
+
     }
+
     else if (expr.__kind__ === reflection_1.ExpressionKind.Detached) {
+
         return `(DETACHED ${renderEdgeQL(expr.__expr__, {
+
             ...ctx,
+
             renderWithVar: expr.__expr__,
+
         }, undefined, true)})`;
+
     }
+
     else {
+
         reflection_1.util.assertNever(expr, new Error(`Unrecognized expression kind: "${expr.__kind__}"`));
+
     }
+
 }
+
 function walkExprTree(_expr, parentScope, ctx) {
+
     var _a, _b, _c, _d;
+
     if (!_expr.__kind__) {
+
         throw new Error(`Expected a valid querybuilder expression, ` +
+
             `instead received ${typeof _expr}${typeof _expr !== "undefined" ? `: '${_expr}'` : ""}.` +
+
             getErrorHint(_expr));
+
     }
+
     const expr = _expr;
+
     if (!ctx.rootScope && parentScope) {
+
         ctx.rootScope = parentScope;
+
     }
+
     const seenExpr = ctx.seen.get(expr);
+
     if (seenExpr) {
+
         seenExpr.refCount += 1;
+
         seenExpr.parentScopes.add(parentScope);
+
         return [expr, ...seenExpr.childExprs];
+
     }
+
     else {
+
         const childExprs = [];
+
         ctx.seen.set(expr, {
+
             refCount: 1,
+
             parentScopes: new Set([parentScope]),
+
             childExprs,
+
             boundScope: null,
+
             aliases: [],
+
             linkProps: [],
+
         });
+
         switch (expr.__kind__) {
+
             case reflection_1.ExpressionKind.Alias:
+
                 childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));
+
                 ctx.seen.get(expr.__expr__).aliases.push(expr);
+
                 break;
+
             case reflection_1.ExpressionKind.With:
+
                 childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));
+
                 for (const refExpr of expr.__refs__) {
+
                     walkExprTree(refExpr, expr.__expr__, ctx);
+
                     const seenRef = ctx.seen.get(refExpr);
+
                     if (seenRef.boundScope) {
+
                         throw new Error(`Expression bound to multiple 'WITH' blocks`);
+
                     }
+
                     seenRef.boundScope = expr.__expr__;
+
                 }
+
                 break;
+
             case reflection_1.ExpressionKind.Literal:
+
             case reflection_1.ExpressionKind.ForVar:
+
             case reflection_1.ExpressionKind.Param:
+
                 break;
+
             case reflection_1.ExpressionKind.PathLeaf:
+
             case reflection_1.ExpressionKind.PathNode:
+
                 if (expr.__parent__) {
+
                     if (expr.__parent__.type.__scopedFrom__) {
+
                         childExprs.push(expr.__parent__.type);
+
                     }
+
                     else {
+
                         childExprs.push(...walkExprTree(expr.__parent__.type, parentScope, ctx));
+
                     }
+
                     if (expr.__kind__ === reflection_1.ExpressionKind.PathLeaf &&
+
                         expr.__parent__.linkName.startsWith("@")) {
+
                         (_a = ctx.seen.get(parentScope)) === null || _a === void 0 ? void 0 : _a.linkProps.push(expr);
+
                     }
+
                 }
+
                 break;
+
             case reflection_1.ExpressionKind.Cast:
+
                 if (expr.__expr__ === null)
+
                     break;
+
                 childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));
+
                 break;
+
             case reflection_1.ExpressionKind.Set:
+
                 for (const subExpr of expr.__exprs__) {
+
                     childExprs.push(...walkExprTree(subExpr, parentScope, ctx));
+
                 }
+
                 break;
+
             case reflection_1.ExpressionKind.Array:
+
                 for (const subExpr of expr.__items__) {
+
                     childExprs.push(...walkExprTree(subExpr, parentScope, ctx));
+
                 }
+
                 break;
+
             case reflection_1.ExpressionKind.Tuple:
+
                 for (const subExpr of expr.__items__) {
+
                     childExprs.push(...walkExprTree(subExpr, parentScope, ctx));
+
                 }
+
                 break;
+
             case reflection_1.ExpressionKind.NamedTuple:
+
                 for (const subExpr of Object.values(expr.__shape__)) {
+
                     childExprs.push(...walkExprTree(subExpr, parentScope, ctx));
+
                 }
+
                 break;
+
             case reflection_1.ExpressionKind.TuplePath:
+
                 childExprs.push(...walkExprTree(expr.__parent__, parentScope, ctx));
+
                 break;
+
             case reflection_1.ExpressionKind.Select:
+
             case reflection_1.ExpressionKind.Update: {
+
                 const modifiers = expr.__modifiers__;
+
                 if (modifiers.filter) {
+
                     childExprs.push(...walkExprTree(modifiers.filter, expr, ctx));
+
                 }
+
                 if (modifiers.order_by) {
+
                     for (const orderExpr of modifiers.order_by) {
+
                         childExprs.push(...walkExprTree(orderExpr.expression, expr, ctx));
+
                     }
+
                 }
+
                 if (modifiers.offset) {
+
                     childExprs.push(...walkExprTree(modifiers.offset, expr, ctx));
+
                 }
+
                 if (modifiers.limit) {
+
                     childExprs.push(...walkExprTree(modifiers.limit, expr, ctx));
+
                 }
+
                 if (expr.__kind__ === reflection_1.ExpressionKind.Select) {
+
                     if ((0, reflection_1.isObjectType)(expr.__element__) &&
+
                         expr.__element__.__shape__ !==
+
                             expr.__expr__.__element__.__shape__) {
+
                         const walkShape = (shape) => {
+
                             for (let param of Object.values(shape)) {
+
                                 if (param.__kind__ === reflection_1.ExpressionKind.PolyShapeElement) {
+
                                     param = param.__shapeElement__;
+
                                 }
+
                                 if (typeof param === "object") {
+
                                     if (!!param.__kind__) {
+
                                         childExprs.push(...walkExprTree(param, expr, ctx));
+
                                     }
+
                                     else {
+
                                         walkShape(param);
+
                                     }
+
                                 }
+
                             }
+
                         };
+
                         walkShape((_b = expr.__element__.__shape__) !== null && _b !== void 0 ? _b : {});
+
                     }
+
                 }
+
                 else {
+
                     const shape = (_c = expr.__shape__) !== null && _c !== void 0 ? _c : {};
+
                     for (const _element of Object.values(shape)) {
+
                         let element = _element;
+
                         if (!element.__element__) {
+
                             if (element["+="])
+
                                 element = element["+="];
+
                             else if (element["-="])
+
                                 element = element["-="];
+
                         }
+
                         childExprs.push(...walkExprTree(element, expr, ctx));
+
                     }
+
                 }
+
                 childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));
+
                 break;
+
             }
+
             case reflection_1.ExpressionKind.Delete: {
+
                 childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));
+
                 break;
+
             }
+
             case reflection_1.ExpressionKind.Insert: {
+
                 const shape = (_d = expr.__shape__) !== null && _d !== void 0 ? _d : {};
+
                 for (const element of Object.values(shape)) {
+
                     childExprs.push(...walkExprTree(element, expr, ctx));
+
                 }
+
                 childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));
+
                 break;
+
             }
+
             case reflection_1.ExpressionKind.InsertUnlessConflict: {
+
                 if (expr.__conflict__.on) {
+
                     childExprs.push(...walkExprTree(expr.__conflict__.on, expr, ctx));
+
                 }
+
                 if (expr.__conflict__.else) {
+
                     childExprs.push(...walkExprTree(expr.__conflict__.else, expr, ctx));
+
                 }
+
                 childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));
+
                 break;
+
             }
+
             case reflection_1.ExpressionKind.TypeIntersection:
+
                 childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));
+
                 break;
+
             case reflection_1.ExpressionKind.Operator:
+
             case reflection_1.ExpressionKind.Function:
+
                 for (const subExpr of expr.__args__) {
+
                     if (Array.isArray(subExpr)) {
+
                         for (const arg of subExpr) {
+
                             if (arg)
+
                                 childExprs.push(...walkExprTree(arg, parentScope, ctx));
+
                         }
+
                     }
+
                     else {
+
                         childExprs.push(...walkExprTree(subExpr, parentScope, ctx));
+
                     }
+
                 }
+
                 if (expr.__kind__ === reflection_1.ExpressionKind.Function) {
+
                     for (const subExpr of Object.values(expr.__namedargs__)) {
+
                         childExprs.push(...walkExprTree(subExpr, parentScope, ctx));
+
                     }
+
                 }
+
                 break;
+
             case reflection_1.ExpressionKind.For: {
+
                 childExprs.push(...walkExprTree(expr.__iterSet__, expr, ctx));
+
                 childExprs.push(...walkExprTree(expr.__expr__, expr, ctx));
+
                 break;
+
             }
+
             case reflection_1.ExpressionKind.WithParams: {
+
                 if (parentScope !== null) {
+
                     throw new Error(`'withParams' does not support being used as a nested expression`);
+
                 }
+
                 childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));
+
                 break;
+
             }
+
             case reflection_1.ExpressionKind.Detached: {
+
                 childExprs.push(...walkExprTree(expr.__expr__, parentScope, ctx));
+
                 break;
+
             }
+
             default:
+
                 reflection_1.util.assertNever(expr, new Error(`Unrecognized expression kind: "${expr.__kind__}"`));
+
         }
+
         return [expr, ...childExprs];
+
     }
+
 }
+
 const numericalTypes = {
+
     "std::number": true,
+
     "std::int16": true,
+
     "std::int32": true,
+
     "std::int64": true,
+
     "std::float32": true,
+
     "std::float64": true,
+
 };
+
 function literalToEdgeQL(type, val) {
+
     let skipCast = false;
+
     let stringRep;
+
     if (typeof val === "string") {
+
         if (numericalTypes[type.__name__]) {
+
             skipCast = true;
+
             stringRep = val;
+
         }
+
         else if (type.__name__ === "std::json") {
+
             skipCast = true;
+
             stringRep = `to_json(${JSON.stringify(val)})`;
+
         }
+
         else if (type.__kind__ === reflection_1.TypeKind.enum) {
+
             skipCast = true;
+
             const vals = type.__values__;
+
             if (vals.includes(val)) {
+
                 skipCast = true;
+
                 stringRep = `${type.__name__}.${val}`;
+
             }
+
             else {
+
                 throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);
+
             }
+
         }
+
         else {
+
             if (type.__name__ === "std::str") {
+
                 skipCast = true;
+
             }
+
             stringRep = JSON.stringify(val);
+
         }
+
     }
+
     else if (typeof val === "number") {
+
         if (numericalTypes[type.__name__]) {
+
             skipCast = true;
+
         }
+
         else {
+
             throw new Error(`Unknown numerical type: ${type.__name__}!`);
+
         }
+
         stringRep = `${val.toString()}`;
+
     }
+
     else if (typeof val === "boolean") {
+
         stringRep = `${val.toString()}`;
+
         skipCast = true;
+
     }
+
     else if (typeof val === "bigint") {
+
         stringRep = `${val.toString()}n`;
+
     }
+
     else if (Array.isArray(val)) {
+
         skipCast = true;
+
         if ((0, reflection_1.isArrayType)(type)) {
+
             stringRep = `[${val
+
                 .map(el => literalToEdgeQL(type.__element__, el))
+
                 .join(", ")}]`;
+
         }
+
         else if ((0, reflection_1.isTupleType)(type)) {
+
             stringRep = `( ${val
+
                 .map((el, j) => literalToEdgeQL(type.__items__[j], el))
+
                 .join(", ")}${type.__items__.length === 1 ? "," : ""} )`;
+
         }
+
         else {
+
             throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);
+
         }
+
     }
+
     else if (val instanceof Date) {
+
         stringRep = `'${val.toISOString()}'`;
+
     }
+
     else if (val instanceof edgedb_1.LocalDate ||
+
         val instanceof edgedb_1.LocalDateTime ||
+
         val instanceof edgedb_1.LocalTime ||
+
         val instanceof edgedb_1.Duration ||
+
         val instanceof edgedb_1.RelativeDuration) {
+
         stringRep = `'${val.toString()}'`;
+
     }
+
     else if (val instanceof Buffer) {
+
         stringRep = bufferToStringRep(val);
+
         skipCast = true;
+
     }
+
     else if (typeof val === "object") {
+
         if ((0, reflection_1.isNamedTupleType)(type)) {
+
             stringRep = `( ${Object.entries(val).map(([key, value]) => `${key} := ${literalToEdgeQL(type.__shape__[key], value)}`)} )`;
+
             skipCast = true;
+
         }
+
         else {
+
             throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);
+
         }
+
     }
+
     else {
+
         throw new Error(`Invalid value for type ${type.__name__}: ${JSON.stringify(val)}`);
+
     }
+
     if (skipCast) {
+
         return stringRep;
+
     }
+
     return `<${type.__name__}>${stringRep}`;
+
 }
+
 function indent(str, depth) {
+
     return str
+
         .split("\n")
+
         .map(line => " ".repeat(depth) + line)
+
         .join("\n");
+
 }
+
 function q(ident, allowReserved = false) {
+
     if (!ident ||
+
         ident.startsWith("@") ||
+
         ident.includes("::") ||
+
         ident.startsWith("<")) {
+
         return ident;
+
     }
+
     const isAlphaNum = /^([^\W\d]\w*|([1-9]\d*|0))$/.test(ident);
+
     const lident = ident.toLowerCase();
+
     const isReserved = lident !== "__type__" &&
+
         lident !== "__std__" &&
+
         reservedKeywords_1.reservedKeywords.includes(lident);
+
     if (isAlphaNum && (allowReserved || !isReserved)) {
+
         return ident;
+
     }
+
     return "`" + ident.replace(/`/g, "``") + "`";
+
 }
+
 function bufferToStringRep(buf) {
+
     let stringRep = "";
+
     for (const byte of buf) {
+
         if (byte < 32 || byte > 126) {
+
             switch (byte) {
+
                 case 8:
+
                     stringRep += "\\b";
+
                     break;
+
                 case 9:
+
                     stringRep += "\\t";
+
                     break;
+
                 case 10:
+
                     stringRep += "\\n";
+
                     break;
+
                 case 12:
+
                     stringRep += "\\f";
+
                     break;
+
                 case 13:
+
                     stringRep += "\\r";
+
                     break;
+
                 default:
+
                     stringRep += `\\x${byte.toString(16).padStart(2, "0")}`;
+
             }
+
         }
+
         else {
+
             stringRep +=
+
                 (byte === 39 || byte === 92 ? "\\" : "") + String.fromCharCode(byte);
+
         }
+
     }
+
     return `b'${stringRep}'`;
+
 }
+
 function getErrorHint(expr) {
+
     let literalConstructor = null;
+
     switch (typeof expr) {
+
         case "string":
+
             literalConstructor = "e.str()";
+
             break;
+
         case "number":
+
             literalConstructor = Number.isInteger(expr)
+
                 ? "e.int64()"
+
                 : "e.float64()";
+
             break;
+
         case "bigint":
+
             literalConstructor = "e.bigint()";
+
             break;
+
         case "boolean":
+
             literalConstructor = "e.bool()";
+
             break;
+
     }
+
     switch (true) {
+
         case expr instanceof Date:
+
             literalConstructor = "e.datetime()";
+
             break;
+
         case expr instanceof edgedb_1.Duration:
+
             literalConstructor = "e.duration()";
+
             break;
+
         case expr instanceof edgedb_1.LocalDate:
+
             literalConstructor = "e.cal.local_date()";
+
             break;
+
         case expr instanceof edgedb_1.LocalDateTime:
+
             literalConstructor = "e.cal.local_datetime()";
+
             break;
+
         case expr instanceof edgedb_1.LocalTime:
+
             literalConstructor = "e.cal.local_time()";
+
             break;
+
         case expr instanceof edgedb_1.RelativeDuration:
+
             literalConstructor = "e.cal.relative_duration()";
+
             break;
+
     }
+
     return literalConstructor
+
         ? `\nHint: Maybe you meant to wrap the value in ` +
+
             `a '${literalConstructor}' expression?`
+
         : "";
+
 }
